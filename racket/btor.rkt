#lang errortrace racket
;;; Utilities for .btor files.

(provide parse-btor
         btor->racket)

(require rosette
         racket/hash
         "lattice-ecp5.rkt"
         "ultrascale.rkt"
         (prefix-in lr: "language.rkt")
         racket/runtime-path)

(define (parse-btor str)

  ;;; Maps ids (number) to bv expressions.
  (define h (make-hash))
  (define (get id)
    (hash-ref h id))
  (define (get-str id-str)
    (get (string->number id-str)))

  (define ins (make-hash))
  (define outs (make-hash))

  (for ([line (filter (lambda (line) (not (equal? #\; (string-ref line 0))))
                      (string-split str #rx"\n+"))])
    ;;; Remove comments.
    (match-let* ([line (first (string-split line ";"))]
                 [(cons id-str tokens) (string-split line)]
                 [id (string->number id-str)])
      (match tokens
        [`("sort" "bitvec" ,width-str) (hash-set! h id (bitvector (string->number width-str)))]
        ;;; Sometimes the .btor files contain inputs without names. I'm unsure what these are. We just
        ;;; ignore them for now.
        ;;;
        ;;; After looking through Yosys code, I think these occur when X values appear in designs.
        [`("input" ,type-id-str)
         (let* ([type (hash-ref h (string->number type-id-str))]
                [const (constant `(unnamed-input ,id) type)])
           ;;; (displayln (format "Unnamed input found with id ~a and type id ~a" id type-id-str)
           ;;;            (current-error-port))
           (hash-set! h id const))]
        [`("input" ,type-id-str ,name)
         (let* ([type (hash-ref h (string->number type-id-str))]
                [const (constant (string->symbol name) type)])
           (hash-set! ins name const)
           (hash-set! h id const))]
        [`("const" ,type-id-str ,value-str)
         (let* ([type (hash-ref h (string->number type-id-str))] [value (string->number value-str 2)])
           (hash-set! h id (bv value type)))]
        [`("ite" ,type-id-str ,cond-id-str ,true-val-id-str ,false-val-id-str)
         (hash-set! h
                    id
                    (if (bitvector->bool (get-str cond-id-str))
                        (get-str true-val-id-str)
                        (get-str false-val-id-str)))]
        [`("slice" ,type-id-str ,val-id-str ,u-str ,l-str)
         (hash-set! h
                    id
                    (extract (string->number u-str) (string->number l-str) (get-str val-id-str)))]
        [`("output" ,id-str ,name)
         (hash-set! outs name (get-str id-str))
         (hash-set! h id name)]
        [`("uext" ,out-type-id-str ,in-id-str ,_ ...)
         (hash-set! h id (zero-extend (get-str in-id-str) (get-str out-type-id-str)))]
        [`("not" ,out-type-id-str ,in-id-str) (hash-set! h id (bvnot (get-str in-id-str)))]
        [`("eq" ,out-type-id-str ,a-id-str ,b-id-str)
         (hash-set! h
                    id
                    (bool->bitvector (bveq (get-str a-id-str) (get-str b-id-str))
                                     (get-str out-type-id-str)))]
        [`("and" ,out-type-id-str ,a-id-str ,b-id-str)
         (hash-set! h id (bvand (get-str a-id-str) (get-str b-id-str)))]
        [`("or" ,out-type-id-str ,a-id-str ,b-id-str)
         (hash-set! h id (bvor (get-str a-id-str) (get-str b-id-str)))]
        [`("xor" ,out-type-id-str ,a-id-str ,b-id-str)
         (hash-set! h id (bvxor (get-str a-id-str) (get-str b-id-str)))]
        [`("concat" ,out-type-id-str ,a-id-str ,b-id-str)
         (hash-set! h id (concat (get-str a-id-str) (get-str b-id-str)))]
        [`("srl" ,out-type-id-str ,a-id-str ,b-id-str)
         (hash-set! h id (bvlshr (get-str a-id-str) (get-str b-id-str)))]
        [`("redor" ,out-type-id-str ,in-id-str)
         (hash-set! h id (apply bvor (bitvector->bits (get-str in-id-str))))]
        [`("redand" ,out-type-id-str ,in-id-str)
         (hash-set! h id (apply bvand (bitvector->bits (get-str in-id-str))))])))

  (list ins outs))

(module+ test
  (require rackunit
           rosette/solver/smt/boolector
           "lut.rkt"
           "interpreter.rkt")

  (current-solver (boolector))

  (test-case
   "Parse a LUT4 and verify its implementation against our lut function."
   (begin
     (match-define (list ins outs)
       (parse-btor
        #<<here-string-delimiter
; BTOR description generated by Yosys 0.15+50 (git sha1 6318db615, x86_64-apple-darwin20.2-clang 10.0.0-4ubuntu1 -fPIC -Os) for module LUT4.
1 sort bitvec 1
2 input 1 A ; myLUT4.v:2.19-2.20
3 input 1 B ; myLUT4.v:2.22-2.23
4 input 1 C ; myLUT4.v:2.25-2.26
5 input 1 D ; myLUT4.v:2.28-2.29
6 sort bitvec 16
7 input 6 INIT ; myLUT4.v:3.17-3.21
8 sort bitvec 8
9 slice 8 7 7 0
10 slice 8 7 15 8
11 ite 8 5 10 9
12 sort bitvec 4
13 slice 12 11 3 0
14 slice 12 11 7 4
15 ite 12 4 14 13
16 sort bitvec 2
17 slice 16 15 1 0
18 slice 16 15 3 2
19 ite 16 3 18 17
20 slice 1 19 0 0
21 slice 1 19 1 1
22 ite 1 2 21 20
23 output 22 Z ; myLUT4.v:2.38-2.39
24 uext 16 19 0 s1 ; myLUT4.v:7.16-7.18
25 uext 12 15 0 s2 ; myLUT4.v:6.16-6.18
26 uext 8 11 0 s3 ; myLUT4.v:5.16-5.18
; end of yosys output
here-string-delimiter
        ;
        ))

     (define A (hash-ref ins "A"))
     (define B (hash-ref ins "B"))
     (define C (hash-ref ins "C"))
     (define D (hash-ref ins "D"))
     (define INIT (hash-ref ins "INIT"))

     ;;; Verify the parsed LUT4 against our implementation of LUT.
     (check-true (unsat? (verify (assert (bveq (hash-ref outs "Z") (lut INIT (concat D C B A)))))))))

  (test-case
   "Parse a LUT4 and verify its implementation against our lut function."
   (begin
     (match-define (list ins outs)
       (parse-btor
        #<<here-string-delimiter
; BTOR description generated by Yosys 0.19+14 (git sha1 2326b9f90, clang 12.0.0 -fPIC -Os) for module CCU2C.
1 sort bitvec 1
2 input 1 A0 ; myCCU2C.v:17.25-17.27
3 input 1 A1 ; myCCU2C.v:17.41-17.43
4 input 1 B0 ; myCCU2C.v:17.29-17.31
5 input 1 B1 ; myCCU2C.v:17.45-17.47
6 input 1 C0 ; myCCU2C.v:17.33-17.35
7 input 1 C1 ; myCCU2C.v:17.49-17.51
8 input 1 CIN ; myCCU2C.v:17.20-17.23
9 input 1 D0 ; myCCU2C.v:17.37-17.39
10 input 1 D1 ; myCCU2C.v:17.53-17.55
11 sort bitvec 16
12 input 11 INIT0 ; myCCU2C.v:18.46-18.51
13 input 11 INIT1 ; myCCU2C.v:18.66-18.71
14 sort bitvec 64
15 input 14 INJECT1_0 ; myCCU2C.v:18.86-18.95
16 input 14 INJECT1_1 ; myCCU2C.v:18.110-18.119
17 sort bitvec 8
18 slice 17 13 7 0
19 slice 17 13 15 8
20 ite 17 10 19 18
21 sort bitvec 4
22 slice 21 20 3 0
23 slice 21 20 7 4
24 ite 21 7 23 22
25 sort bitvec 2
26 slice 25 24 1 0
27 slice 25 24 3 2
28 ite 25 5 27 26
29 slice 1 28 0 0
30 slice 1 28 1 1
31 ite 1 3 30 29
32 not 1 31
33 slice 25 13 1 0
34 slice 25 13 3 2
35 ite 25 5 34 33
36 slice 1 35 0 0
37 slice 1 35 1 1
38 ite 1 3 37 36
39 const 1 0
40 sort bitvec 24
41 const 40 010110010100010101010011
42 uext 14 41 40
43 eq 1 16 42
44 ite 1 43 39 38
45 and 1 32 44
46 slice 17 12 7 0
47 slice 17 12 15 8
48 ite 17 9 47 46
49 slice 21 48 3 0
50 slice 21 48 7 4
51 ite 21 6 50 49
52 slice 25 51 1 0
53 slice 25 51 3 2
54 ite 25 4 53 52
55 slice 1 54 0 0
56 slice 1 54 1 1
57 ite 1 2 56 55
58 not 1 57
59 slice 25 12 1 0
60 slice 25 12 3 2
61 ite 25 4 60 59
62 slice 1 61 0 0
63 slice 1 61 1 1
64 ite 1 2 63 62
65 uext 14 41 40
66 eq 1 15 65
67 ite 1 66 39 64
68 and 1 58 67
69 and 1 57 8
70 or 1 68 69
71 and 1 31 70
72 or 1 45 71
73 output 72 COUT ; myCCU2C.v:18.28-18.32
74 uext 14 41 40
75 eq 1 15 74
76 ite 1 75 39 8
77 xor 1 57 76
78 output 77 S0 ; myCCU2C.v:18.20-18.22
79 uext 14 41 40
80 eq 1 16 79
81 ite 1 80 39 70
82 xor 1 31 81
83 output 82 S1 ; myCCU2C.v:18.24-18.26
84 uext 1 64 0 LUT2_0 ; myCCU2C.v:26.15-26.21
85 uext 1 38 0 LUT2_1 ; myCCU2C.v:37.15-37.21
86 uext 1 57 0 LUT4_0 ; myCCU2C.v:26.7-26.13
87 uext 1 31 0 LUT4_1 ; myCCU2C.v:37.7-37.13
88 uext 1 70 0 cout_0 ; myCCU2C.v:34.7-34.13
89 uext 1 76 0 gated_cin_0 ; myCCU2C.v:30.7-30.18
90 uext 1 81 0 gated_cin_1 ; myCCU2C.v:41.7-41.18
91 uext 1 67 0 gated_lut2_0 ; myCCU2C.v:33.7-33.19
92 uext 1 44 0 gated_lut2_1 ; myCCU2C.v:44.7-44.19
93 uext 1 2 0 lut2_0.A ; myCCU2C.v:28.9-28.62|myCCU2C.v:11.19-11.20
94 uext 1 4 0 lut2_0.B ; myCCU2C.v:28.9-28.62|myCCU2C.v:11.22-11.23
95 slice 21 12 3 0
96 uext 21 95 0 lut2_0.INIT ; myCCU2C.v:28.9-28.62|myCCU2C.v:12.16-12.20
97 uext 1 64 0 lut2_0.Z ; myCCU2C.v:28.9-28.62|myCCU2C.v:11.32-11.33
98 uext 25 61 0 lut2_0.s1 ; myCCU2C.v:28.9-28.62|myCCU2C.v:14.16-14.18
99 uext 1 3 0 lut2_1.A ; myCCU2C.v:39.9-39.62|myCCU2C.v:11.19-11.20
100 uext 1 5 0 lut2_1.B ; myCCU2C.v:39.9-39.62|myCCU2C.v:11.22-11.23
101 slice 21 13 3 0
102 uext 21 101 0 lut2_1.INIT ; myCCU2C.v:39.9-39.62|myCCU2C.v:12.16-12.20
103 uext 1 38 0 lut2_1.Z ; myCCU2C.v:39.9-39.62|myCCU2C.v:11.32-11.33
104 uext 25 35 0 lut2_1.s1 ; myCCU2C.v:39.9-39.62|myCCU2C.v:14.16-14.18
105 uext 1 2 0 lut4_0.A ; myCCU2C.v:27.9-27.73|myCCU2C.v:3.19-3.20
106 uext 1 4 0 lut4_0.B ; myCCU2C.v:27.9-27.73|myCCU2C.v:3.22-3.23
107 uext 1 6 0 lut4_0.C ; myCCU2C.v:27.9-27.73|myCCU2C.v:3.25-3.26
108 uext 1 9 0 lut4_0.D ; myCCU2C.v:27.9-27.73|myCCU2C.v:3.28-3.29
109 uext 11 12 0 lut4_0.INIT ; myCCU2C.v:27.9-27.73|myCCU2C.v:4.17-4.21
110 uext 1 57 0 lut4_0.Z ; myCCU2C.v:27.9-27.73|myCCU2C.v:3.38-3.39
111 uext 25 54 0 lut4_0.s1 ; myCCU2C.v:27.9-27.73|myCCU2C.v:8.16-8.18
112 uext 21 51 0 lut4_0.s2 ; myCCU2C.v:27.9-27.73|myCCU2C.v:7.16-7.18
113 uext 17 48 0 lut4_0.s3 ; myCCU2C.v:27.9-27.73|myCCU2C.v:6.16-6.18
114 uext 1 3 0 lut4_1.A ; myCCU2C.v:38.9-38.73|myCCU2C.v:3.19-3.20
115 uext 1 5 0 lut4_1.B ; myCCU2C.v:38.9-38.73|myCCU2C.v:3.22-3.23
116 uext 1 7 0 lut4_1.C ; myCCU2C.v:38.9-38.73|myCCU2C.v:3.25-3.26
117 uext 1 10 0 lut4_1.D ; myCCU2C.v:38.9-38.73|myCCU2C.v:3.28-3.29
118 uext 11 13 0 lut4_1.INIT ; myCCU2C.v:38.9-38.73|myCCU2C.v:4.17-4.21
119 uext 1 31 0 lut4_1.Z ; myCCU2C.v:38.9-38.73|myCCU2C.v:3.38-3.39
120 uext 25 28 0 lut4_1.s1 ; myCCU2C.v:38.9-38.73|myCCU2C.v:8.16-8.18
121 uext 21 24 0 lut4_1.s2 ; myCCU2C.v:38.9-38.73|myCCU2C.v:7.16-7.18
122 uext 17 20 0 lut4_1.s3 ; myCCU2C.v:38.9-38.73|myCCU2C.v:6.16-6.18
; end of yosys output
here-string-delimiter
        ;
        ))

     (match-define (hash-table ("S0" S0) ("S1" S1) ("COUT" COUT)) outs)

     (match-define (hash-table ("A0" A0)
                               ("A1" A1)
                               ("B0" B0)
                               ("B1" B1)
                               ("C0" C0)
                               ("C1" C1)
                               ("CIN" CIN)
                               ("D0" D0)
                               ("D1" D1)
                               ("INIT0" INIT0)
                               ("INIT1" INIT1)
                               ("INJECT1_0" INJECT1_0)
                               ("INJECT1_1" INJECT1_1))
       ins)

     (check-equal?
      (unsat)
      (verify (begin

                (assume (bvzero? INJECT1_0))
                (assume (bvzero? INJECT1_1))

                (match-define (list iS0 iS1 iCOUT)
                  (interpret (lattice-ecp5-ccu2c INIT0
                                                 INIT1
                                                 (bv 0 1)
                                                 (bv 0 1)
                                                 CIN
                                                 (list (concat D0 C0 B0 A0) (concat D1 C1 B1 A1)))))
                (assert (bveq S0 iS0))
                (assert (bveq S1 iS1))
                (assert (bveq COUT iCOUT)))))))

  (test-case
   "Parse a Xilinx LUT4 and verify its implementation against our lut function."
   (begin
     (match-define (list ins outs)
       (parse-btor
        #<<here-string-delimiter
; BTOR description generated by Yosys 0.15+50 (git sha1 6318db615, x86_64-apple-darwin20.2-clang 10.0.0-4ubuntu1 -fPIC -Os) for module LUT4.
1 sort bitvec 1
2 input 1 I0 ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:44.9-44.11
3 input 1 I1 ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:45.9-45.11
4 input 1 I2 ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:46.9-46.11
5 input 1 I3 ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:47.9-47.11
6 sort bitvec 16
7 input 6 INIT ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:48.16-48.20
8 input 1
9 sort bitvec 4
10 input 1
11 slice 9 7 3 0
12 const 1 0
13 sort bitvec 2
14 concat 13 3 12
15 uext 9 14 2
16 srl 9 11 15
17 slice 1 16 0 0
18 const 1 1
19 eq 1 3 18
20 eq 1 3 12
21 or 1 19 20
22 uext 9 14 2
23 srl 9 11 22
24 slice 1 23 0 0
25 concat 13 3 18
26 uext 9 25 2
27 srl 9 11 26
28 slice 1 27 0 0
29 eq 1 24 28
30 and 1 21 29
31 ite 1 30 17 10
32 input 1
33 eq 1 2 18
34 eq 1 2 12
35 or 1 33 34
36 concat 13 12 2
37 uext 9 36 2
38 srl 9 11 37
39 slice 1 38 0 0
40 concat 13 18 2
41 uext 9 40 2
42 srl 9 11 41
43 slice 1 42 0 0
44 eq 1 39 43
45 and 1 35 44
46 ite 1 45 32 31
47 input 1
48 redor 1 11
49 not 1 48
50 redand 1 11
51 or 1 49 50
52 ite 1 51 47 46
53 input 1
54 xor 1 3 2
55 eq 1 54 18
56 xor 1 3 2
57 eq 1 56 12
58 or 1 55 57
59 ite 1 58 53 52
60 input 1
61 redor 1 7
62 not 1 61
63 redand 1 7
64 or 1 62 63
65 ite 1 64 60 59
66 input 1
67 xor 1 2 3
68 xor 1 67 4
69 xor 1 68 5
70 eq 1 69 12
71 xor 1 2 3
72 xor 1 71 4
73 xor 1 72 5
74 eq 1 73 18
75 or 1 70 74
76 ite 1 75 66 65
77 uext 9 36 2
78 srl 9 11 77
79 slice 1 78 0 0
80 ite 1 45 79 76
81 input 1
82 ite 1 51 81 80
83 input 1
84 ite 1 58 83 82
85 input 1
86 ite 1 64 85 84
87 input 1
88 ite 1 75 87 86
89 slice 1 7 0 0
90 ite 1 51 89 88
91 input 1
92 ite 1 58 91 90
93 input 1
94 ite 1 64 93 92
95 input 1
96 ite 1 75 95 94
97 concat 13 3 2
98 uext 9 97 2
99 srl 9 11 98
100 slice 1 99 0 0
101 ite 1 58 100 96
102 input 1
103 ite 1 64 102 101
104 input 1
105 ite 1 75 104 103
106 input 1
107 slice 9 7 7 4
108 uext 9 14 2
109 srl 9 107 108
110 slice 1 109 0 0
111 eq 1 3 18
112 eq 1 3 12
113 or 1 111 112
114 uext 9 14 2
115 srl 9 107 114
116 slice 1 115 0 0
117 uext 9 25 2
118 srl 9 107 117
119 slice 1 118 0 0
120 eq 1 116 119
121 and 1 113 120
122 ite 1 121 110 106
123 input 1
124 eq 1 2 18
125 eq 1 2 12
126 or 1 124 125
127 uext 9 36 2
128 srl 9 107 127
129 slice 1 128 0 0
130 uext 9 40 2
131 srl 9 107 130
132 slice 1 131 0 0
133 eq 1 129 132
134 and 1 126 133
135 ite 1 134 123 122
136 input 1
137 redor 1 107
138 not 1 137
139 redand 1 107
140 or 1 138 139
141 ite 1 140 136 135
142 input 1
143 xor 1 3 2
144 eq 1 143 18
145 xor 1 3 2
146 eq 1 145 12
147 or 1 144 146
148 ite 1 147 142 141
149 input 1
150 ite 1 64 149 148
151 input 1
152 ite 1 75 151 150
153 uext 9 36 2
154 srl 9 107 153
155 slice 1 154 0 0
156 ite 1 134 155 152
157 input 1
158 ite 1 140 157 156
159 input 1
160 ite 1 147 159 158
161 input 1
162 ite 1 64 161 160
163 input 1
164 ite 1 75 163 162
165 slice 1 7 4 4
166 ite 1 140 165 164
167 input 1
168 ite 1 147 167 166
169 input 1
170 ite 1 64 169 168
171 input 1
172 ite 1 75 171 170
173 uext 9 97 2
174 srl 9 107 173
175 slice 1 174 0 0
176 ite 1 147 175 172
177 input 1
178 ite 1 64 177 176
179 input 1
180 ite 1 75 179 178
181 input 1
182 slice 9 7 11 8
183 uext 9 14 2
184 srl 9 182 183
185 slice 1 184 0 0
186 eq 1 3 18
187 eq 1 3 12
188 or 1 186 187
189 uext 9 14 2
190 srl 9 182 189
191 slice 1 190 0 0
192 uext 9 25 2
193 srl 9 182 192
194 slice 1 193 0 0
195 eq 1 191 194
196 and 1 188 195
197 ite 1 196 185 181
198 input 1
199 eq 1 2 18
200 eq 1 2 12
201 or 1 199 200
202 uext 9 36 2
203 srl 9 182 202
204 slice 1 203 0 0
205 uext 9 40 2
206 srl 9 182 205
207 slice 1 206 0 0
208 eq 1 204 207
209 and 1 201 208
210 ite 1 209 198 197
211 input 1
212 redor 1 182
213 not 1 212
214 redand 1 182
215 or 1 213 214
216 ite 1 215 211 210
217 input 1
218 xor 1 3 2
219 eq 1 218 18
220 xor 1 3 2
221 eq 1 220 12
222 or 1 219 221
223 ite 1 222 217 216
224 input 1
225 ite 1 64 224 223
226 input 1
227 ite 1 75 226 225
228 uext 9 36 2
229 srl 9 182 228
230 slice 1 229 0 0
231 ite 1 209 230 227
232 input 1
233 ite 1 215 232 231
234 input 1
235 ite 1 222 234 233
236 input 1
237 ite 1 64 236 235
238 input 1
239 ite 1 75 238 237
240 slice 1 7 8 8
241 ite 1 215 240 239
242 input 1
243 ite 1 222 242 241
244 input 1
245 ite 1 64 244 243
246 input 1
247 ite 1 75 246 245
248 uext 9 97 2
249 srl 9 182 248
250 slice 1 249 0 0
251 ite 1 222 250 247
252 input 1
253 ite 1 64 252 251
254 input 1
255 ite 1 75 254 253
256 input 1
257 slice 9 7 15 12
258 uext 9 14 2
259 srl 9 257 258
260 slice 1 259 0 0
261 eq 1 3 18
262 eq 1 3 12
263 or 1 261 262
264 uext 9 14 2
265 srl 9 257 264
266 slice 1 265 0 0
267 uext 9 25 2
268 srl 9 257 267
269 slice 1 268 0 0
270 eq 1 266 269
271 and 1 263 270
272 ite 1 271 260 256
273 input 1
274 eq 1 2 18
275 eq 1 2 12
276 or 1 274 275
277 uext 9 36 2
278 srl 9 257 277
279 slice 1 278 0 0
280 uext 9 40 2
281 srl 9 257 280
282 slice 1 281 0 0
283 eq 1 279 282
284 and 1 276 283
285 ite 1 284 273 272
286 input 1
287 redor 1 257
288 not 1 287
289 redand 1 257
290 or 1 288 289
291 ite 1 290 286 285
292 input 1
293 xor 1 3 2
294 eq 1 293 18
295 xor 1 3 2
296 eq 1 295 12
297 or 1 294 296
298 ite 1 297 292 291
299 input 1
300 ite 1 64 299 298
301 input 1
302 ite 1 75 301 300
303 uext 9 36 2
304 srl 9 257 303
305 slice 1 304 0 0
306 ite 1 284 305 302
307 input 1
308 ite 1 290 307 306
309 input 1
310 ite 1 297 309 308
311 input 1
312 ite 1 64 311 310
313 input 1
314 ite 1 75 313 312
315 slice 1 7 12 12
316 ite 1 290 315 314
317 input 1
318 ite 1 297 317 316
319 input 1
320 ite 1 64 319 318
321 input 1
322 ite 1 75 321 320
323 uext 9 97 2
324 srl 9 257 323
325 slice 1 324 0 0
326 ite 1 297 325 322
327 input 1
328 ite 1 64 327 326
329 input 1
330 ite 1 75 329 328
331 concat 13 180 105
332 sort bitvec 3
333 concat 332 255 331
334 concat 9 330 333
335 concat 13 5 12
336 uext 9 335 2
337 srl 9 334 336
338 slice 1 337 0 0
339 eq 1 5 18
340 eq 1 5 12
341 or 1 339 340
342 uext 9 335 2
343 srl 9 334 342
344 slice 1 343 0 0
345 concat 13 5 18
346 uext 9 345 2
347 srl 9 334 346
348 slice 1 347 0 0
349 eq 1 344 348
350 and 1 341 349
351 ite 1 350 338 8
352 input 1
353 eq 1 4 18
354 eq 1 4 12
355 or 1 353 354
356 concat 13 12 4
357 uext 9 356 2
358 srl 9 334 357
359 slice 1 358 0 0
360 concat 13 18 4
361 uext 9 360 2
362 srl 9 334 361
363 slice 1 362 0 0
364 eq 1 359 363
365 and 1 355 364
366 ite 1 365 352 351
367 input 1
368 redor 1 334
369 not 1 368
370 redand 1 334
371 or 1 369 370
372 ite 1 371 367 366
373 input 1
374 xor 1 5 4
375 eq 1 374 18
376 xor 1 5 4
377 eq 1 376 12
378 or 1 375 377
379 ite 1 378 373 372
380 input 1
381 ite 1 64 380 379
382 input 1
383 ite 1 75 382 381
384 uext 9 356 2
385 srl 9 334 384
386 slice 1 385 0 0
387 ite 1 365 386 383
388 input 1
389 ite 1 371 388 387
390 input 1
391 ite 1 378 390 389
392 input 1
393 ite 1 64 392 391
394 input 1
395 ite 1 75 394 393
396 ite 1 371 105 395
397 input 1
398 ite 1 378 397 396
399 input 1
400 ite 1 64 399 398
401 input 1
402 ite 1 75 401 400
403 concat 13 5 4
404 uext 9 403 2
405 srl 9 334 404
406 slice 1 405 0 0
407 ite 1 378 406 402
408 input 1
409 ite 1 64 408 407
410 input 1
411 ite 1 75 410 409
412 ite 1 64 89 411
413 input 1
414 ite 1 75 413 412
415 concat 13 3 2
416 concat 332 4 415
417 concat 9 5 416
418 uext 6 417 12
419 srl 6 7 418
420 slice 1 419 0 0
421 ite 1 75 420 414
422 output 421 O ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:42.10-42.11
423 uext 6 7 0 INIT_REG ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:56.14-56.22
424 uext 1 421 0 O_out ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:61.7-61.12
425 input 1
426 uext 1 425 0 lut_mux4_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:88$4.$result ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:0.0-0.0
427 input 9
428 uext 9 427 0 lut_mux4_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:88$4.d ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:66.15-66.16
429 input 13
430 uext 13 429 0 lut_mux4_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:88$4.s ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:67.15-67.16
431 input 1
432 uext 1 431 0 lut_mux4_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:88$5.$result ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:0.0-0.0
433 input 9
434 uext 9 433 0 lut_mux4_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:88$5.d ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:66.15-66.16
435 input 13
436 uext 13 435 0 lut_mux4_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:88$5.s ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:67.15-67.16
437 input 1
438 uext 1 437 0 lut_mux4_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:89$3.$result ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:0.0-0.0
439 input 9
440 uext 9 439 0 lut_mux4_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:89$3.d ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:66.15-66.16
441 input 13
442 uext 13 441 0 lut_mux4_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:89$3.s ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:67.15-67.16
443 input 1
444 uext 1 443 0 lut_mux4_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:90$2.$result ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:0.0-0.0
445 input 9
446 uext 9 445 0 lut_mux4_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:90$2.d ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:66.15-66.16
447 input 13
448 uext 13 447 0 lut_mux4_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:90$2.s ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:67.15-67.16
449 input 1
450 uext 1 449 0 lut_mux4_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:91$1.$result ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:0.0-0.0
451 input 9
452 uext 9 451 0 lut_mux4_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:91$1.d ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:66.15-66.16
453 input 13
454 uext 13 453 0 lut_mux4_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:91$1.s ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:67.15-67.16
455 uext 1 12 0 trig_attr ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmpyvu9t704:53.7-53.16
; end of yosys output
here-string-delimiter
        ;
        ))

     (match-define (hash-table ("O" O)) outs)

     (match-define (hash-table ("I0" I0) ("I1" I1) ("I2" I2) ("I3" I3) ("INIT" INIT)) ins)
     (check-equal? (unsat) (verify (assert (bveq O (lut INIT (concat I3 I2 I1 I0))))))))

  (test-case
   "Parse a Xilinx LUT6_2 and verify its implementation against our lut function."
   (begin
     (clear-terms!)
     (match-define (list ins outs)
       (parse-btor
        #<<here-string-delimiter
; BTOR description generated by Yosys 0.15+50 (git sha1 6318db615, x86_64-apple-darwin20.2-clang 10.0.0-4ubuntu1 -fPIC -Os) for module LUT6_2.
1 sort bitvec 1
2 input 1 I0 ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:45.9-45.11
3 input 1 I1 ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:46.9-46.11
4 input 1 I2 ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:47.9-47.11
5 input 1 I3 ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:48.9-48.11
6 input 1 I4 ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:49.9-49.11
7 input 1 I5 ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:50.9-50.11
8 sort bitvec 64
9 input 8 INIT ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:51.16-51.20
10 input 1
11 sort bitvec 4
12 input 1
13 sort bitvec 8
14 slice 13 9 7 0
15 sort bitvec 2
16 const 15 00
17 sort bitvec 3
18 concat 17 4 16
19 uext 13 18 5
20 srl 13 14 19
21 slice 1 20 0 0
22 const 1 1
23 eq 1 4 22
24 const 1 0
25 eq 1 4 24
26 or 1 23 25
27 const 15 01
28 concat 17 4 27
29 uext 13 28 5
30 srl 13 14 29
31 slice 1 30 0 0
32 eq 1 21 31
33 and 1 26 32
34 const 15 10
35 concat 17 4 34
36 uext 13 35 5
37 srl 13 14 36
38 slice 1 37 0 0
39 eq 1 21 38
40 and 1 33 39
41 const 15 11
42 concat 17 4 41
43 uext 13 42 5
44 srl 13 14 43
45 slice 1 44 0 0
46 eq 1 21 45
47 and 1 40 46
48 ite 1 47 21 12
49 concat 15 3 24
50 uext 13 49 6
51 srl 13 14 50
52 slice 1 51 0 0
53 eq 1 3 22
54 eq 1 3 24
55 or 1 53 54
56 concat 15 3 22
57 uext 13 56 6
58 srl 13 14 57
59 slice 1 58 0 0
60 eq 1 52 59
61 and 1 55 60
62 concat 15 3 24
63 concat 17 22 62
64 uext 13 63 5
65 srl 13 14 64
66 slice 1 65 0 0
67 eq 1 52 66
68 and 1 61 67
69 concat 15 3 22
70 concat 17 22 69
71 uext 13 70 5
72 srl 13 14 71
73 slice 1 72 0 0
74 eq 1 52 73
75 and 1 68 74
76 ite 1 75 52 48
77 uext 13 2 7
78 srl 13 14 77
79 slice 1 78 0 0
80 eq 1 2 22
81 eq 1 2 24
82 or 1 80 81
83 concat 15 22 2
84 uext 13 83 6
85 srl 13 14 84
86 slice 1 85 0 0
87 eq 1 79 86
88 and 1 82 87
89 concat 17 34 2
90 uext 13 89 5
91 srl 13 14 90
92 slice 1 91 0 0
93 eq 1 79 92
94 and 1 88 93
95 concat 17 41 2
96 uext 13 95 5
97 srl 13 14 96
98 slice 1 97 0 0
99 eq 1 79 98
100 and 1 94 99
101 ite 1 100 79 76
102 concat 15 3 24
103 concat 17 4 102
104 uext 13 103 5
105 srl 13 14 104
106 slice 1 105 0 0
107 xor 1 4 3
108 eq 1 107 22
109 eq 1 107 24
110 or 1 108 109
111 concat 15 3 22
112 concat 17 4 111
113 uext 13 112 5
114 srl 13 14 113
115 slice 1 114 0 0
116 eq 1 106 115
117 and 1 110 116
118 ite 1 117 106 101
119 concat 15 24 2
120 concat 17 4 119
121 uext 13 120 5
122 srl 13 14 121
123 slice 1 122 0 0
124 xor 1 4 2
125 eq 1 124 22
126 eq 1 124 24
127 or 1 125 126
128 concat 15 22 2
129 concat 17 4 128
130 uext 13 129 5
131 srl 13 14 130
132 slice 1 131 0 0
133 eq 1 123 132
134 and 1 127 133
135 ite 1 134 123 118
136 concat 15 3 2
137 uext 13 136 6
138 srl 13 14 137
139 slice 1 138 0 0
140 xor 1 2 3
141 eq 1 140 22
142 eq 1 140 24
143 or 1 141 142
144 concat 15 3 2
145 concat 17 22 144
146 uext 13 145 5
147 srl 13 14 146
148 slice 1 147 0 0
149 eq 1 139 148
150 and 1 143 149
151 ite 1 150 139 135
152 slice 1 9 0 0
153 redor 1 14
154 not 1 153
155 redand 1 14
156 or 1 154 155
157 ite 1 156 152 151
158 concat 15 3 2
159 concat 17 4 158
160 uext 13 159 5
161 srl 13 14 160
162 slice 1 161 0 0
163 xor 1 107 2
164 eq 1 163 22
165 eq 1 163 24
166 or 1 164 165
167 ite 1 166 162 157
168 input 1
169 sort bitvec 32
170 slice 169 9 31 0
171 redor 1 170
172 not 1 171
173 redand 1 170
174 or 1 172 173
175 ite 1 174 168 167
176 input 1
177 xor 1 140 4
178 xor 1 177 5
179 xor 1 178 6
180 eq 1 179 24
181 eq 1 179 22
182 or 1 180 181
183 ite 1 182 176 175
184 input 1
185 slice 13 9 15 8
186 uext 13 18 5
187 srl 13 185 186
188 slice 1 187 0 0
189 uext 13 28 5
190 srl 13 185 189
191 slice 1 190 0 0
192 eq 1 188 191
193 and 1 26 192
194 uext 13 35 5
195 srl 13 185 194
196 slice 1 195 0 0
197 eq 1 188 196
198 and 1 193 197
199 uext 13 42 5
200 srl 13 185 199
201 slice 1 200 0 0
202 eq 1 188 201
203 and 1 198 202
204 ite 1 203 188 184
205 uext 13 49 6
206 srl 13 185 205
207 slice 1 206 0 0
208 uext 13 56 6
209 srl 13 185 208
210 slice 1 209 0 0
211 eq 1 207 210
212 and 1 55 211
213 uext 13 63 5
214 srl 13 185 213
215 slice 1 214 0 0
216 eq 1 207 215
217 and 1 212 216
218 uext 13 70 5
219 srl 13 185 218
220 slice 1 219 0 0
221 eq 1 207 220
222 and 1 217 221
223 ite 1 222 207 204
224 uext 13 2 7
225 srl 13 185 224
226 slice 1 225 0 0
227 uext 13 83 6
228 srl 13 185 227
229 slice 1 228 0 0
230 eq 1 226 229
231 and 1 82 230
232 uext 13 89 5
233 srl 13 185 232
234 slice 1 233 0 0
235 eq 1 226 234
236 and 1 231 235
237 uext 13 95 5
238 srl 13 185 237
239 slice 1 238 0 0
240 eq 1 226 239
241 and 1 236 240
242 ite 1 241 226 223
243 uext 13 103 5
244 srl 13 185 243
245 slice 1 244 0 0
246 uext 13 112 5
247 srl 13 185 246
248 slice 1 247 0 0
249 eq 1 245 248
250 and 1 110 249
251 ite 1 250 245 242
252 uext 13 120 5
253 srl 13 185 252
254 slice 1 253 0 0
255 uext 13 129 5
256 srl 13 185 255
257 slice 1 256 0 0
258 eq 1 254 257
259 and 1 127 258
260 ite 1 259 254 251
261 uext 13 136 6
262 srl 13 185 261
263 slice 1 262 0 0
264 uext 13 145 5
265 srl 13 185 264
266 slice 1 265 0 0
267 eq 1 263 266
268 and 1 143 267
269 ite 1 268 263 260
270 slice 1 9 8 8
271 redor 1 185
272 not 1 271
273 redand 1 185
274 or 1 272 273
275 ite 1 274 270 269
276 uext 13 159 5
277 srl 13 185 276
278 slice 1 277 0 0
279 ite 1 166 278 275
280 input 1
281 ite 1 174 280 279
282 input 1
283 ite 1 182 282 281
284 input 1
285 slice 13 9 23 16
286 uext 13 18 5
287 srl 13 285 286
288 slice 1 287 0 0
289 uext 13 28 5
290 srl 13 285 289
291 slice 1 290 0 0
292 eq 1 288 291
293 and 1 26 292
294 uext 13 35 5
295 srl 13 285 294
296 slice 1 295 0 0
297 eq 1 288 296
298 and 1 293 297
299 uext 13 42 5
300 srl 13 285 299
301 slice 1 300 0 0
302 eq 1 288 301
303 and 1 298 302
304 ite 1 303 288 284
305 uext 13 49 6
306 srl 13 285 305
307 slice 1 306 0 0
308 uext 13 56 6
309 srl 13 285 308
310 slice 1 309 0 0
311 eq 1 307 310
312 and 1 55 311
313 uext 13 63 5
314 srl 13 285 313
315 slice 1 314 0 0
316 eq 1 307 315
317 and 1 312 316
318 uext 13 70 5
319 srl 13 285 318
320 slice 1 319 0 0
321 eq 1 307 320
322 and 1 317 321
323 ite 1 322 307 304
324 uext 13 2 7
325 srl 13 285 324
326 slice 1 325 0 0
327 uext 13 83 6
328 srl 13 285 327
329 slice 1 328 0 0
330 eq 1 326 329
331 and 1 82 330
332 uext 13 89 5
333 srl 13 285 332
334 slice 1 333 0 0
335 eq 1 326 334
336 and 1 331 335
337 uext 13 95 5
338 srl 13 285 337
339 slice 1 338 0 0
340 eq 1 326 339
341 and 1 336 340
342 ite 1 341 326 323
343 uext 13 103 5
344 srl 13 285 343
345 slice 1 344 0 0
346 uext 13 112 5
347 srl 13 285 346
348 slice 1 347 0 0
349 eq 1 345 348
350 and 1 110 349
351 ite 1 350 345 342
352 uext 13 120 5
353 srl 13 285 352
354 slice 1 353 0 0
355 uext 13 129 5
356 srl 13 285 355
357 slice 1 356 0 0
358 eq 1 354 357
359 and 1 127 358
360 ite 1 359 354 351
361 uext 13 136 6
362 srl 13 285 361
363 slice 1 362 0 0
364 uext 13 145 5
365 srl 13 285 364
366 slice 1 365 0 0
367 eq 1 363 366
368 and 1 143 367
369 ite 1 368 363 360
370 slice 1 9 16 16
371 redor 1 285
372 not 1 371
373 redand 1 285
374 or 1 372 373
375 ite 1 374 370 369
376 uext 13 159 5
377 srl 13 285 376
378 slice 1 377 0 0
379 ite 1 166 378 375
380 input 1
381 ite 1 174 380 379
382 input 1
383 ite 1 182 382 381
384 input 1
385 slice 13 9 31 24
386 uext 13 18 5
387 srl 13 385 386
388 slice 1 387 0 0
389 uext 13 28 5
390 srl 13 385 389
391 slice 1 390 0 0
392 eq 1 388 391
393 and 1 26 392
394 uext 13 35 5
395 srl 13 385 394
396 slice 1 395 0 0
397 eq 1 388 396
398 and 1 393 397
399 uext 13 42 5
400 srl 13 385 399
401 slice 1 400 0 0
402 eq 1 388 401
403 and 1 398 402
404 ite 1 403 388 384
405 uext 13 49 6
406 srl 13 385 405
407 slice 1 406 0 0
408 uext 13 56 6
409 srl 13 385 408
410 slice 1 409 0 0
411 eq 1 407 410
412 and 1 55 411
413 uext 13 63 5
414 srl 13 385 413
415 slice 1 414 0 0
416 eq 1 407 415
417 and 1 412 416
418 uext 13 70 5
419 srl 13 385 418
420 slice 1 419 0 0
421 eq 1 407 420
422 and 1 417 421
423 ite 1 422 407 404
424 uext 13 2 7
425 srl 13 385 424
426 slice 1 425 0 0
427 uext 13 83 6
428 srl 13 385 427
429 slice 1 428 0 0
430 eq 1 426 429
431 and 1 82 430
432 uext 13 89 5
433 srl 13 385 432
434 slice 1 433 0 0
435 eq 1 426 434
436 and 1 431 435
437 uext 13 95 5
438 srl 13 385 437
439 slice 1 438 0 0
440 eq 1 426 439
441 and 1 436 440
442 ite 1 441 426 423
443 uext 13 103 5
444 srl 13 385 443
445 slice 1 444 0 0
446 uext 13 112 5
447 srl 13 385 446
448 slice 1 447 0 0
449 eq 1 445 448
450 and 1 110 449
451 ite 1 450 445 442
452 uext 13 120 5
453 srl 13 385 452
454 slice 1 453 0 0
455 uext 13 129 5
456 srl 13 385 455
457 slice 1 456 0 0
458 eq 1 454 457
459 and 1 127 458
460 ite 1 459 454 451
461 uext 13 136 6
462 srl 13 385 461
463 slice 1 462 0 0
464 uext 13 145 5
465 srl 13 385 464
466 slice 1 465 0 0
467 eq 1 463 466
468 and 1 143 467
469 ite 1 468 463 460
470 slice 1 9 24 24
471 redor 1 385
472 not 1 471
473 redand 1 385
474 or 1 472 473
475 ite 1 474 470 469
476 uext 13 159 5
477 srl 13 385 476
478 slice 1 477 0 0
479 ite 1 166 478 475
480 input 1
481 ite 1 174 480 479
482 input 1
483 ite 1 182 482 481
484 concat 15 283 183
485 concat 17 383 484
486 concat 11 483 485
487 concat 15 6 24
488 uext 11 487 2
489 srl 11 486 488
490 slice 1 489 0 0
491 eq 1 6 22
492 eq 1 6 24
493 or 1 491 492
494 concat 15 6 22
495 uext 11 494 2
496 srl 11 486 495
497 slice 1 496 0 0
498 eq 1 490 497
499 and 1 493 498
500 ite 1 499 490 10
501 uext 11 5 3
502 srl 11 486 501
503 slice 1 502 0 0
504 eq 1 5 22
505 eq 1 5 24
506 or 1 504 505
507 concat 15 22 5
508 uext 11 507 2
509 srl 11 486 508
510 slice 1 509 0 0
511 eq 1 503 510
512 and 1 506 511
513 ite 1 512 503 500
514 redor 1 486
515 not 1 514
516 redand 1 486
517 or 1 515 516
518 ite 1 517 183 513
519 concat 15 6 5
520 uext 11 519 2
521 srl 11 486 520
522 slice 1 521 0 0
523 xor 1 6 5
524 eq 1 523 22
525 eq 1 523 24
526 or 1 524 525
527 ite 1 526 522 518
528 ite 1 174 152 527
529 concat 15 3 2
530 concat 17 4 529
531 concat 11 5 530
532 sort bitvec 5
533 concat 532 6 531
534 uext 8 533 59
535 srl 8 9 534
536 slice 1 535 0 0
537 ite 1 182 536 528
538 output 537 O5 ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:42.10-42.12
539 input 1
540 input 1
541 redor 1 9
542 not 1 541
543 redand 1 9
544 or 1 542 543
545 ite 1 544 540 167
546 input 1
547 xor 1 179 7
548 eq 1 547 24
549 eq 1 547 22
550 or 1 548 549
551 ite 1 550 546 545
552 input 1
553 ite 1 544 552 279
554 input 1
555 ite 1 550 554 553
556 input 1
557 ite 1 544 556 379
558 input 1
559 ite 1 550 558 557
560 input 1
561 ite 1 544 560 479
562 input 1
563 ite 1 550 562 561
564 input 1
565 slice 13 9 39 32
566 uext 13 18 5
567 srl 13 565 566
568 slice 1 567 0 0
569 uext 13 28 5
570 srl 13 565 569
571 slice 1 570 0 0
572 eq 1 568 571
573 and 1 26 572
574 uext 13 35 5
575 srl 13 565 574
576 slice 1 575 0 0
577 eq 1 568 576
578 and 1 573 577
579 uext 13 42 5
580 srl 13 565 579
581 slice 1 580 0 0
582 eq 1 568 581
583 and 1 578 582
584 ite 1 583 568 564
585 uext 13 49 6
586 srl 13 565 585
587 slice 1 586 0 0
588 uext 13 56 6
589 srl 13 565 588
590 slice 1 589 0 0
591 eq 1 587 590
592 and 1 55 591
593 uext 13 63 5
594 srl 13 565 593
595 slice 1 594 0 0
596 eq 1 587 595
597 and 1 592 596
598 uext 13 70 5
599 srl 13 565 598
600 slice 1 599 0 0
601 eq 1 587 600
602 and 1 597 601
603 ite 1 602 587 584
604 uext 13 2 7
605 srl 13 565 604
606 slice 1 605 0 0
607 uext 13 83 6
608 srl 13 565 607
609 slice 1 608 0 0
610 eq 1 606 609
611 and 1 82 610
612 uext 13 89 5
613 srl 13 565 612
614 slice 1 613 0 0
615 eq 1 606 614
616 and 1 611 615
617 uext 13 95 5
618 srl 13 565 617
619 slice 1 618 0 0
620 eq 1 606 619
621 and 1 616 620
622 ite 1 621 606 603
623 uext 13 103 5
624 srl 13 565 623
625 slice 1 624 0 0
626 uext 13 112 5
627 srl 13 565 626
628 slice 1 627 0 0
629 eq 1 625 628
630 and 1 110 629
631 ite 1 630 625 622
632 uext 13 120 5
633 srl 13 565 632
634 slice 1 633 0 0
635 uext 13 129 5
636 srl 13 565 635
637 slice 1 636 0 0
638 eq 1 634 637
639 and 1 127 638
640 ite 1 639 634 631
641 uext 13 136 6
642 srl 13 565 641
643 slice 1 642 0 0
644 uext 13 145 5
645 srl 13 565 644
646 slice 1 645 0 0
647 eq 1 643 646
648 and 1 143 647
649 ite 1 648 643 640
650 slice 1 9 32 32
651 redor 1 565
652 not 1 651
653 redand 1 565
654 or 1 652 653
655 ite 1 654 650 649
656 uext 13 159 5
657 srl 13 565 656
658 slice 1 657 0 0
659 ite 1 166 658 655
660 input 1
661 ite 1 544 660 659
662 input 1
663 ite 1 550 662 661
664 input 1
665 slice 13 9 47 40
666 uext 13 18 5
667 srl 13 665 666
668 slice 1 667 0 0
669 uext 13 28 5
670 srl 13 665 669
671 slice 1 670 0 0
672 eq 1 668 671
673 and 1 26 672
674 uext 13 35 5
675 srl 13 665 674
676 slice 1 675 0 0
677 eq 1 668 676
678 and 1 673 677
679 uext 13 42 5
680 srl 13 665 679
681 slice 1 680 0 0
682 eq 1 668 681
683 and 1 678 682
684 ite 1 683 668 664
685 uext 13 49 6
686 srl 13 665 685
687 slice 1 686 0 0
688 uext 13 56 6
689 srl 13 665 688
690 slice 1 689 0 0
691 eq 1 687 690
692 and 1 55 691
693 uext 13 63 5
694 srl 13 665 693
695 slice 1 694 0 0
696 eq 1 687 695
697 and 1 692 696
698 uext 13 70 5
699 srl 13 665 698
700 slice 1 699 0 0
701 eq 1 687 700
702 and 1 697 701
703 ite 1 702 687 684
704 uext 13 2 7
705 srl 13 665 704
706 slice 1 705 0 0
707 uext 13 83 6
708 srl 13 665 707
709 slice 1 708 0 0
710 eq 1 706 709
711 and 1 82 710
712 uext 13 89 5
713 srl 13 665 712
714 slice 1 713 0 0
715 eq 1 706 714
716 and 1 711 715
717 uext 13 95 5
718 srl 13 665 717
719 slice 1 718 0 0
720 eq 1 706 719
721 and 1 716 720
722 ite 1 721 706 703
723 uext 13 103 5
724 srl 13 665 723
725 slice 1 724 0 0
726 uext 13 112 5
727 srl 13 665 726
728 slice 1 727 0 0
729 eq 1 725 728
730 and 1 110 729
731 ite 1 730 725 722
732 uext 13 120 5
733 srl 13 665 732
734 slice 1 733 0 0
735 uext 13 129 5
736 srl 13 665 735
737 slice 1 736 0 0
738 eq 1 734 737
739 and 1 127 738
740 ite 1 739 734 731
741 uext 13 136 6
742 srl 13 665 741
743 slice 1 742 0 0
744 uext 13 145 5
745 srl 13 665 744
746 slice 1 745 0 0
747 eq 1 743 746
748 and 1 143 747
749 ite 1 748 743 740
750 slice 1 9 40 40
751 redor 1 665
752 not 1 751
753 redand 1 665
754 or 1 752 753
755 ite 1 754 750 749
756 uext 13 159 5
757 srl 13 665 756
758 slice 1 757 0 0
759 ite 1 166 758 755
760 input 1
761 ite 1 544 760 759
762 input 1
763 ite 1 550 762 761
764 input 1
765 slice 13 9 55 48
766 uext 13 18 5
767 srl 13 765 766
768 slice 1 767 0 0
769 uext 13 28 5
770 srl 13 765 769
771 slice 1 770 0 0
772 eq 1 768 771
773 and 1 26 772
774 uext 13 35 5
775 srl 13 765 774
776 slice 1 775 0 0
777 eq 1 768 776
778 and 1 773 777
779 uext 13 42 5
780 srl 13 765 779
781 slice 1 780 0 0
782 eq 1 768 781
783 and 1 778 782
784 ite 1 783 768 764
785 uext 13 49 6
786 srl 13 765 785
787 slice 1 786 0 0
788 uext 13 56 6
789 srl 13 765 788
790 slice 1 789 0 0
791 eq 1 787 790
792 and 1 55 791
793 uext 13 63 5
794 srl 13 765 793
795 slice 1 794 0 0
796 eq 1 787 795
797 and 1 792 796
798 uext 13 70 5
799 srl 13 765 798
800 slice 1 799 0 0
801 eq 1 787 800
802 and 1 797 801
803 ite 1 802 787 784
804 uext 13 2 7
805 srl 13 765 804
806 slice 1 805 0 0
807 uext 13 83 6
808 srl 13 765 807
809 slice 1 808 0 0
810 eq 1 806 809
811 and 1 82 810
812 uext 13 89 5
813 srl 13 765 812
814 slice 1 813 0 0
815 eq 1 806 814
816 and 1 811 815
817 uext 13 95 5
818 srl 13 765 817
819 slice 1 818 0 0
820 eq 1 806 819
821 and 1 816 820
822 ite 1 821 806 803
823 uext 13 103 5
824 srl 13 765 823
825 slice 1 824 0 0
826 uext 13 112 5
827 srl 13 765 826
828 slice 1 827 0 0
829 eq 1 825 828
830 and 1 110 829
831 ite 1 830 825 822
832 uext 13 120 5
833 srl 13 765 832
834 slice 1 833 0 0
835 uext 13 129 5
836 srl 13 765 835
837 slice 1 836 0 0
838 eq 1 834 837
839 and 1 127 838
840 ite 1 839 834 831
841 uext 13 136 6
842 srl 13 765 841
843 slice 1 842 0 0
844 uext 13 145 5
845 srl 13 765 844
846 slice 1 845 0 0
847 eq 1 843 846
848 and 1 143 847
849 ite 1 848 843 840
850 slice 1 9 48 48
851 redor 1 765
852 not 1 851
853 redand 1 765
854 or 1 852 853
855 ite 1 854 850 849
856 uext 13 159 5
857 srl 13 765 856
858 slice 1 857 0 0
859 ite 1 166 858 855
860 input 1
861 ite 1 544 860 859
862 input 1
863 ite 1 550 862 861
864 input 1
865 slice 13 9 63 56
866 uext 13 18 5
867 srl 13 865 866
868 slice 1 867 0 0
869 uext 13 28 5
870 srl 13 865 869
871 slice 1 870 0 0
872 eq 1 868 871
873 and 1 26 872
874 uext 13 35 5
875 srl 13 865 874
876 slice 1 875 0 0
877 eq 1 868 876
878 and 1 873 877
879 uext 13 42 5
880 srl 13 865 879
881 slice 1 880 0 0
882 eq 1 868 881
883 and 1 878 882
884 ite 1 883 868 864
885 uext 13 49 6
886 srl 13 865 885
887 slice 1 886 0 0
888 uext 13 56 6
889 srl 13 865 888
890 slice 1 889 0 0
891 eq 1 887 890
892 and 1 55 891
893 uext 13 63 5
894 srl 13 865 893
895 slice 1 894 0 0
896 eq 1 887 895
897 and 1 892 896
898 uext 13 70 5
899 srl 13 865 898
900 slice 1 899 0 0
901 eq 1 887 900
902 and 1 897 901
903 ite 1 902 887 884
904 uext 13 2 7
905 srl 13 865 904
906 slice 1 905 0 0
907 uext 13 83 6
908 srl 13 865 907
909 slice 1 908 0 0
910 eq 1 906 909
911 and 1 82 910
912 uext 13 89 5
913 srl 13 865 912
914 slice 1 913 0 0
915 eq 1 906 914
916 and 1 911 915
917 uext 13 95 5
918 srl 13 865 917
919 slice 1 918 0 0
920 eq 1 906 919
921 and 1 916 920
922 ite 1 921 906 903
923 uext 13 103 5
924 srl 13 865 923
925 slice 1 924 0 0
926 uext 13 112 5
927 srl 13 865 926
928 slice 1 927 0 0
929 eq 1 925 928
930 and 1 110 929
931 ite 1 930 925 922
932 uext 13 120 5
933 srl 13 865 932
934 slice 1 933 0 0
935 uext 13 129 5
936 srl 13 865 935
937 slice 1 936 0 0
938 eq 1 934 937
939 and 1 127 938
940 ite 1 939 934 931
941 uext 13 136 6
942 srl 13 865 941
943 slice 1 942 0 0
944 uext 13 145 5
945 srl 13 865 944
946 slice 1 945 0 0
947 eq 1 943 946
948 and 1 143 947
949 ite 1 948 943 940
950 slice 1 9 56 56
951 redor 1 865
952 not 1 951
953 redand 1 865
954 or 1 952 953
955 ite 1 954 950 949
956 uext 13 159 5
957 srl 13 865 956
958 slice 1 957 0 0
959 ite 1 166 958 955
960 input 1
961 ite 1 544 960 959
962 input 1
963 ite 1 550 962 961
964 concat 15 555 551
965 concat 17 559 964
966 concat 11 563 965
967 concat 532 663 966
968 sort bitvec 6
969 concat 968 763 967
970 sort bitvec 7
971 concat 970 863 969
972 concat 13 963 971
973 concat 17 7 16
974 uext 13 973 5
975 srl 13 972 974
976 slice 1 975 0 0
977 eq 1 7 22
978 eq 1 7 24
979 or 1 977 978
980 concat 17 7 27
981 uext 13 980 5
982 srl 13 972 981
983 slice 1 982 0 0
984 eq 1 976 983
985 and 1 979 984
986 concat 17 7 34
987 uext 13 986 5
988 srl 13 972 987
989 slice 1 988 0 0
990 eq 1 976 989
991 and 1 985 990
992 concat 17 7 41
993 uext 13 992 5
994 srl 13 972 993
995 slice 1 994 0 0
996 eq 1 976 995
997 and 1 991 996
998 ite 1 997 976 539
999 uext 13 487 6
1000 srl 13 972 999
1001 slice 1 1000 0 0
1002 uext 13 494 6
1003 srl 13 972 1002
1004 slice 1 1003 0 0
1005 eq 1 1001 1004
1006 and 1 493 1005
1007 concat 15 6 24
1008 concat 17 22 1007
1009 uext 13 1008 5
1010 srl 13 972 1009
1011 slice 1 1010 0 0
1012 eq 1 1001 1011
1013 and 1 1006 1012
1014 concat 15 6 22
1015 concat 17 22 1014
1016 uext 13 1015 5
1017 srl 13 972 1016
1018 slice 1 1017 0 0
1019 eq 1 1001 1018
1020 and 1 1013 1019
1021 ite 1 1020 1001 998
1022 uext 13 5 7
1023 srl 13 972 1022
1024 slice 1 1023 0 0
1025 uext 13 507 6
1026 srl 13 972 1025
1027 slice 1 1026 0 0
1028 eq 1 1024 1027
1029 and 1 506 1028
1030 concat 17 34 5
1031 uext 13 1030 5
1032 srl 13 972 1031
1033 slice 1 1032 0 0
1034 eq 1 1024 1033
1035 and 1 1029 1034
1036 concat 17 41 5
1037 uext 13 1036 5
1038 srl 13 972 1037
1039 slice 1 1038 0 0
1040 eq 1 1024 1039
1041 and 1 1035 1040
1042 ite 1 1041 1024 1021
1043 concat 15 6 24
1044 concat 17 7 1043
1045 uext 13 1044 5
1046 srl 13 972 1045
1047 slice 1 1046 0 0
1048 xor 1 7 6
1049 eq 1 1048 22
1050 eq 1 1048 24
1051 or 1 1049 1050
1052 concat 15 6 22
1053 concat 17 7 1052
1054 uext 13 1053 5
1055 srl 13 972 1054
1056 slice 1 1055 0 0
1057 eq 1 1047 1056
1058 and 1 1051 1057
1059 ite 1 1058 1047 1042
1060 concat 15 24 5
1061 concat 17 7 1060
1062 uext 13 1061 5
1063 srl 13 972 1062
1064 slice 1 1063 0 0
1065 xor 1 7 5
1066 eq 1 1065 22
1067 eq 1 1065 24
1068 or 1 1066 1067
1069 concat 15 22 5
1070 concat 17 7 1069
1071 uext 13 1070 5
1072 srl 13 972 1071
1073 slice 1 1072 0 0
1074 eq 1 1064 1073
1075 and 1 1068 1074
1076 ite 1 1075 1064 1059
1077 uext 13 519 6
1078 srl 13 972 1077
1079 slice 1 1078 0 0
1080 concat 15 6 5
1081 concat 17 22 1080
1082 uext 13 1081 5
1083 srl 13 972 1082
1084 slice 1 1083 0 0
1085 eq 1 1079 1084
1086 and 1 526 1085
1087 ite 1 1086 1079 1076
1088 redor 1 972
1089 not 1 1088
1090 redand 1 972
1091 or 1 1089 1090
1092 ite 1 1091 551 1087
1093 concat 15 6 5
1094 concat 17 7 1093
1095 uext 13 1094 5
1096 srl 13 972 1095
1097 slice 1 1096 0 0
1098 xor 1 1048 5
1099 eq 1 1098 22
1100 eq 1 1098 24
1101 or 1 1099 1100
1102 ite 1 1101 1097 1092
1103 ite 1 544 152 1102
1104 concat 15 3 2
1105 concat 17 4 1104
1106 concat 11 5 1105
1107 concat 532 6 1106
1108 concat 968 7 1107
1109 uext 8 1108 58
1110 srl 8 9 1109
1111 slice 1 1110 0 0
1112 ite 1 550 1111 1103
1113 output 1112 O6 ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:43.10-43.12
1114 uext 8 9 0 INIT_REG ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:59.14-59.22
1115 uext 1 537 0 O5_out ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:64.7-64.13
1116 uext 1 1112 0 O6_out ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:65.7-65.13
1117 input 11
1118 uext 11 1117 0 lut_mux4_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:130$5.d ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:71.15-71.16
1119 input 15
1120 uext 15 1119 0 lut_mux4_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:130$5.s ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:72.15-72.16
1121 input 13
1122 uext 13 1121 0 lut_mux8_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:130$4.d ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:88.15-88.16
1123 input 17
1124 uext 17 1123 0 lut_mux8_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:130$4.s ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:89.15-89.16
1125 input 13
1126 uext 13 1125 0 lut_mux8_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:131$3.d ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:88.15-88.16
1127 input 17
1128 uext 17 1127 0 lut_mux8_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:131$3.s ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:89.15-89.16
1129 input 13
1130 uext 13 1129 0 lut_mux8_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:132$2.d ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:88.15-88.16
1131 input 17
1132 uext 17 1131 0 lut_mux8_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:132$2.s ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:89.15-89.16
1133 input 13
1134 uext 13 1133 0 lut_mux8_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:133$1.d ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:88.15-88.16
1135 input 17
1136 uext 17 1135 0 lut_mux8_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:133$1.s ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:89.15-89.16
1137 input 13
1138 uext 13 1137 0 lut_mux8_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:142$13.d ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:88.15-88.16
1139 input 17
1140 uext 17 1139 0 lut_mux8_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:142$13.s ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:89.15-89.16
1141 input 13
1142 uext 13 1141 0 lut_mux8_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:142$14.d ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:88.15-88.16
1143 input 17
1144 uext 17 1143 0 lut_mux8_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:142$14.s ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:89.15-89.16
1145 input 13
1146 uext 13 1145 0 lut_mux8_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:143$12.d ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:88.15-88.16
1147 input 17
1148 uext 17 1147 0 lut_mux8_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:143$12.s ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:89.15-89.16
1149 input 13
1150 uext 13 1149 0 lut_mux8_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:144$11.d ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:88.15-88.16
1151 input 17
1152 uext 17 1151 0 lut_mux8_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:144$11.s ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:89.15-89.16
1153 input 13
1154 uext 13 1153 0 lut_mux8_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:145$10.d ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:88.15-88.16
1155 input 17
1156 uext 17 1155 0 lut_mux8_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:145$10.s ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:89.15-89.16
1157 input 13
1158 uext 13 1157 0 lut_mux8_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:146$9.d ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:88.15-88.16
1159 input 17
1160 uext 17 1159 0 lut_mux8_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:146$9.s ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:89.15-89.16
1161 input 13
1162 uext 13 1161 0 lut_mux8_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:147$8.d ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:88.15-88.16
1163 input 17
1164 uext 17 1163 0 lut_mux8_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:147$8.s ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:89.15-89.16
1165 input 13
1166 uext 13 1165 0 lut_mux8_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:148$7.d ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:88.15-88.16
1167 input 17
1168 uext 17 1167 0 lut_mux8_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:148$7.s ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:89.15-89.16
1169 input 13
1170 uext 13 1169 0 lut_mux8_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:149$6.d ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:88.15-88.16
1171 input 17
1172 uext 17 1171 0 lut_mux8_f$func$/var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:149$6.s ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:89.15-89.16
1173 uext 1 24 0 trig_attr ; /var/folders/sn/pdf_xchx1ts04qtq3thd9s1c0000gn/T/tmptn2iv71n:56.7-56.16
; end of yosys output
here-string-delimiter
        ;
        ))

     (match-define (hash-table ("O5" O5) ("O6" O6)) outs)
     (match-define (hash-table ("I0" I0)
                               ("I1" I1)
                               ("I2" I2)
                               ("I3" I3)
                               ("I4" I4)
                               ("I5" I5)
                               ("INIT" INIT))
       ins)

     (check-equal?
      (verify (begin
                (match-define (list lrO5 lrO6)
                  (interpret
                   (ultrascale-plus-lut6-2
                    INIT
                    (lr:concat
                     (list I5
                           (lr:concat
                            (list I4
                                  (lr:concat
                                   (list I3 (lr:concat (list I2 (lr:concat (list I1 I0)))))))))))))
                (assert (bveq O5 lrO5))
                (assert (bveq O6 lrO6))))
      (unsat)))))

(require "stateful-design-experiment.rkt")

(define (parse-btor-new str)

  ;;; Maps ids (number) to signals.
  (define h (make-hash))
  (define (get id)
    (hash-ref h id))
  (define (get-str id-str)
    (get (string->number id-str)))

  ;;; Input signals.
  (define ins (list))

  ;;; Outputs. Maps name (string) to id in h of the expression defining the output.
  (define outs (make-hash))

  ;;; States. Maps ids (integers) to signals.
  (define state (make-hash))

  ;;; Maps IDs to state symbols.
  (define state-symbols (make-hash))

  ;;; Maps state symbols to state types.
  (define state-types (make-hash))

  ;;; The state collected from the input.
  (define input-state (make-hash))

  (define output-state (make-hash))

  ;;; Maps input symbol to type.
  (define input-types (make-hash))

  ;;; Initial values of states. Maps state symbol (e.g. 'state0) to expression representing the state
  ;;; value.
  (define init-states (make-hash))

  (for ([line (filter (lambda (line) (not (equal? #\; (string-ref line 0))))
                      (string-split str #rx"\n+"))])
    ;;; Remove comments.
    (match-let* ([line (first (string-split line ";"))]
                 [(cons id-str tokens) (string-split line)]
                 [id (string->number id-str)])
      (match tokens
        [`("next" ,sort-id-str ,state-id-str ,next-val-id-str)
         ;;; A next statement determines the value of the state var that we return out.
         ;;; We build a hash map that maps state symbols (e.g. 'state0) to the expressions that convey
         ;;; the output value for the state.
         (hash-set! output-state
                    (hash-ref state-symbols (string->number state-id-str))
                    (get-str next-val-id-str))
         ;;; We don't put anything in h for next statements.
         ]
        [`("init" ,sort-id-str ,state-id-str ,val-id-str)

         (hash-set! init-states
                    (hash-ref state-symbols (string->number state-id-str))
                    (get-str val-id-str))]
        [`("state" ,sort-id-str)
         ;;; It should draw from the incoming state. But how? The problem is that, with our current
         ;;; setup, i think you have to get the state value from a "nearby" signal that's also in
         ;;; context. Does there need to be some kind of top level wrapper that holds state? state can
         ;;; only be associated with values, but that doesn't make sense. what about a module that
         ;;; takes no inputs (not even a clock) and yet has a state? Does that make sense? does it make
         ;;; sense? I think that thing can only be a constant. If it doesn't take an input, there's
         ;;; nothing to trigger internal state difference. A register doesn't work without a clock. if
         ;;; you have a register, you need a clock, or the register won't function. You can have a
         ;;; combinational loop, but that doesn't really make much sense in our framework. Or, it
         ;;; could, but i guess it depends on what level we consider state changes as happening. For
         ;;; the most part, I guess it's on the callee to determine what state they care to track.

         ;;; The value is either
         ;;;
         ;;; - the lookup of the state id in the state dictionary, or
         ;;;
         ;;; - the init value, if it's not there.
         ;;;
         ;;; But what is the state dictionary? this is a context-dependent thing, isn't it?
         ;;;
         ;;; So I think there's a dict that we build up from a merger of the state values on the inputs
         ;;; to the module, and then that's the dictionary we'd use here. So if there's no inputs,
         ;;; there's no state. Does that make sense? State without input is a constant? I guess so.
         ;;; it would always be the init value, or if there's no init value...well idk.
         (let* ([name-symbol (string->symbol (format "state~a" id))])
           ;;; From the collection of inputs, find the state value by name and convert it to a signal.
           ;;; TODO handle init values.
           ;;; TODO handle names.
           (hash-set! state-symbols id name-symbol)
           (hash-set! state-types name-symbol (get-str sort-id-str))
           (hash-set! h id `(get-state ,ins ,name-symbol)))]
        [`("sort" "bitvec" ,width-str) (hash-set! h id (bitvector (string->number width-str)))]
        ;;; Sometimes the .btor files contain inputs without names. I'm unsure what these are. We just
        ;;; ignore them for now.
        [`("input" ,type-id-str)
         (set! ins (append ins (list (string->symbol (format "unnamed-input-~a" id)))))
         (hash-set! input-types (string->symbol (format "unnamed-input-~a" id)) (get-str type-id-str))
         (hash-set! h id (string->symbol (format "unnamed-input-~a" id)))]
        ;;; A named input should get a symbol representing it. That symbol will be looked up in the
        ;;; call to the interpreter. We also actually don't do anything with the type anymore---we
        ;;; could use it to do type checking, but for now we'll ignore it.
        [`("input" ,type-id-str ,name)
         (set! ins (append ins (list (string->symbol name))))
         (hash-set! input-types (string->symbol name) (get-str type-id-str))
         (hash-set! h id (string->symbol name))]
        [`("const" ,type-id-str ,value-str)
         (let* ([type (get-str type-id-str)] [value (string->number value-str 2)])
           (hash-set! h id (bv->signal (bv value type))))]
        [`("ite" ,type-id-str ,cond-id-str ,true-val-id-str ,false-val-id-str)
         (let ([true-val (get-str true-val-id-str)]
               [false-val (get-str false-val-id-str)]
               [cond-val (get-str cond-id-str)])
           (hash-set! h id `(if ,cond-val ,true-val ,false-val)))]
        [`("slice" ,type-id-str ,val-id-str ,u-str ,l-str)
         (let ([signal (get-str val-id-str)])
           (hash-set! h id (lr:extract (string->number u-str) (string->number l-str) signal)))]
        [`("output" ,id-str ,name)
         (hash-set! outs (string->symbol name) (string->number id-str))
         ;;;(hash-set! h id (get-str id-str))
         ]
        [`("uext" ,out-type-id-str ,in-id-str ,_ ...)
         (let ([signal (get-str in-id-str)])
           (hash-set! h id (lr:zero-extend signal (get-str out-type-id-str))))]
        [`("concat" ,out-type-id-str ,a-id-str ,b-id-str)
         (let ([a-signal (get-str a-id-str)] [b-signal (get-str b-id-str)])
           (hash-set! h id (lr:concat (list a-signal b-signal))))]
        [`("add" ,out-type-id-str ,a-id-str ,b-id-str)
         (let ([a-signal (get-str a-id-str)] [b-signal (get-str b-id-str)])
           (hash-set! h id `(bvadd ,a-signal ,b-signal)))]
        [`("xor" ,out-type-id-str ,a-id-str ,b-id-str)
         (let ([a-signal (get-str a-id-str)] [b-signal (get-str b-id-str)])
           (hash-set! h id `(bvxor ,a-signal ,b-signal)))]
        [`("and" ,out-type-id-str ,a-id-str ,b-id-str)
         (let ([a-signal (get-str a-id-str)] [b-signal (get-str b-id-str)])
           (hash-set! h id `(bvand ,a-signal ,b-signal)))]
        [`("sub" ,out-type-id-str ,a-id-str ,b-id-str)
         (let ([a-signal (get-str a-id-str)] [b-signal (get-str b-id-str)])
           (hash-set! h id `(bvsub ,a-signal ,b-signal)))]
        [`("or" ,out-type-id-str ,a-id-str ,b-id-str)
         (let ([a-signal (get-str a-id-str)] [b-signal (get-str b-id-str)])
           (hash-set! h id `(bvor ,a-signal ,b-signal)))]
        [`("redor" ,out-type-id-str ,in-id-str) (hash-set! h id `(redor ,(get-str in-id-str)))]
        [`("redxor" ,out-type-id-str ,in-id-str) (hash-set! h id `(redxor ,(get-str in-id-str)))]
        [`("mul" ,out-type-id-str ,a-id-str ,b-id-str)
         (let ([a-signal (get-str a-id-str)] [b-signal (get-str b-id-str)])
           (hash-set! h id `(bvmul ,a-signal ,b-signal)))]
        [`("redand" ,out-type-id-str ,in-id-str) (hash-set! h id `(redand ,(get-str in-id-str)))]
        [`("not" ,out-type-id-str ,in-id-str)
         (let ([signal (get-str in-id-str)]) (hash-set! h id `(bvnot ,signal)))]
        [`("eq" ,out-type-id-str ,a-id-str ,b-id-str)
         (let ([a (get-str a-id-str)] [b (get-str b-id-str)]) (hash-set! h id `(bveq ,a ,b)))]
        [`("neq" ,out-type-id-str ,a-id-str ,b-id-str)
         (let ([a (get-str a-id-str)] [b (get-str b-id-str)])
           (hash-set! h id `(bvnot (bveq ,a ,b))))])))

  ;;; Update outputs to have new output states.
  (define new-outs
    (foldl (λ (k new-outs)
             (hash-set new-outs k `(set-state ,(hash-ref h (hash-ref outs k)) ,output-state)))
           (hash)
           (hash-keys outs)))

  ;;; Fill in 0s for all states that don't have initial values. This may be a bad default. I think
  ;;; these states are produced by Yosys when X values are present, but it also seems like they
  ;;; come up when DFF or memories are present.
  ;;;
  ;;; TODO(@gussmith23) Is this a good idea?
  (define init-full
    (hash-union
     (make-immutable-hash (hash->list init-states))
     ;;; Get all the keys that don't have init values, set them to 0 (of the correct type) and make
     ;;; a hash out of them.
     (make-immutable-hash (map (λ (key) (cons key (bv->signal (bv 0 (hash-ref state-types key)))))
                               (filter (λ (key) (not (hash-has-key? init-states key)))
                                       (hash-values state-symbols))))))

  (list ins new-outs init-full output-state (hash-values state-symbols) state-types input-types))

;;; Runtime path of stateful-design-experiment file, needed for codegen.
(define-runtime-path stateful-design-experiment-runtime-path "stateful-design-experiment.rkt")

;;; Takes a btor file as a string.
;;;
;;; default-value: All input values are assumed to be optional. This argument controls the default
;;; value for each input. 'symbolic means default arguments will be symbolic bitvectors wrapped in
;;; signals.
;;;
;;; Returns:
;;; - A function representing the btor file. The function returns a map, mapping output symbols to
;;;   their values.
;;; - A list of strings representing the requires needed for the generated code.
;;;
;;; TODO(@gussmith): We rely heavily on hash tables for this implementation. Hash tables are not
;;; lifted in Rosette, and thus we have to be very careful with them. In general, I think these are
;;; the rules to obey when using hash tables in Rosette:
;;; - Only use immutable hash tables.
;;; - Keys should never be symbolic. They should always be concrete.
(define (btor->racket str #:default-value [default-value 'symbolic])

  ;;; Input signals.
  (define ins (list))

  ;;; Outputs. Maps name (string) to id in h of the expression defining the output.
  (define outs (make-hash))

  ;;; States. Maps ids (integers) to signals.
  (define state (make-hash))

  ;;; Maps IDs (integers) to state symbols.
  (define state-symbols (make-hash))

  ;;; Maps state symbols to state types (bitvector?).
  (define state-types (make-hash))

  ;;; The state collected from the input.
  (define input-state (make-hash))

  ;;; Maps state symbol to let-clause symbol representing its next/output value.
  (define output-state (make-hash))

  ;;; Maps input symbol to type.
  (define input-types (make-hash))

  ;;; Initial values of states. Maps state symbol (e.g. 'state0) to let*-clause symbol representing
  ;;; the state value.
  (define init-states (make-hash))

  ;;; Maps btor id (generated by btor-id-str->id) to (bitvector?) type.
  (define sorts (make-hash))

  ;;; Helper for generating code for computing an op over signal arguments. Converts the args to bvs,
  ;;; computes the op, and then converts back to signal.
  (define (op-call-builder op . signal-exprs)
    (let ([signal-vals (map (λ (signal-expr) `(signal-value ,signal-expr)) signal-exprs)])
      `(signal (,op ,@signal-vals) (merge-state (list ,@signal-exprs)))))

  ;;; Reduction op builder helper.
  (define (redop-call-builder op signal-expr)
    `(signal (apply ,op (bitvector->bits (signal-value ,signal-expr))) (signal-state ,signal-expr)))

  ;;; Comparison op builder helper.
  (define (compop-call-builder op . signal-exprs)
    (let ([signal-vals (map (λ (signal-expr) `(signal-value ,signal-expr)) signal-exprs)])
      `(signal (bool->bitvector (,op ,@signal-vals)) (merge-state (list ,@signal-exprs)))))

  (define (id-str-to-btor-id id-str)
    (string->symbol (format "btor~a" id-str)))
  ;;; Maps a btor-id (as an integer) to the expression for that id.
  (define let*-clauses (list))
  (define (add-expr symbol expr)
    (set! let*-clauses (append let*-clauses (list `[,symbol ,expr]))))
  (define (add-expr-id-str id-str expr)
    (add-expr (id-str-to-btor-id id-str) expr))
  (define (get-expr-id-str id-str)
    (id-str-to-btor-id id-str))

  ;;; The expression representing the initial state values hash.
  (define init-hash '(hash))
  ;;; The symbol to which the above init hash expression will be bound via a let clause.
  (define init-hash-symbol 'init-hash)

  ;;; The expression representing the merged state
  (define merged-input-state-hash '(hash))
  (define merged-input-state-hash-symbol 'merged-input-state-hash)
  ;;; Add initial (empty) input state hash.
  (add-expr merged-input-state-hash-symbol merged-input-state-hash)

  ;;; The expression for the output state hash.
  (define output-state-hash '(hash))

  ;;; Annoyingly, initial state values are defined at the end of btor files, but we need the init
  ;;; values at the beginning. So we do a first pass to compile the init values.

  ;;; Given an btor-id in string form, returns a bv? expression representing that btor id.
  ;;; Used only for initial state preprocessing.
  (define (simple-compile btor-id-str)
    ;;; Find the line that equals
    (define matching-lines
      (filter
       (lambda (line)
         (match-let* ;;; Remove comments.
             ([line (first (string-split line ";"))] [(cons id-str tokens) (string-split line)])
           (equal? id-str btor-id-str)))
       ;; Split file into lines and filter empty lines.
       (filter (lambda (line) (not (equal? #\; (string-ref line 0)))) (string-split str #rx"\n+"))))

    (when (not (equal? (length matching-lines) 1))
      (error "expected exactly 1 match"))

    ;;; Remove comments.
    (match-let* ([line (first matching-lines)]
                 [line (first (string-split line ";"))]
                 [(cons id-str tokens) (string-split line)]
                 [id (string->number id-str)])
      (match tokens
        [`("sort" "bitvec" ,bw-str) `(bitvector ,(string->number bw-str))]
        [`("const" ,sort-id-str ,value-str)
         `(bv ,(string->number value-str 2) ,(simple-compile sort-id-str))])))

  ;;; First pass to compile init values.
  (for ([line (filter (lambda (line) (not (equal? #\; (string-ref line 0))))
                      (string-split str #rx"\n+"))])
    ;;; Remove comments.
    (match-let* ([line (first (string-split line ";"))]
                 [(cons id-str tokens) (string-split line)]
                 [id (string->number id-str)])
      (match tokens
        [`("init" ,sort-id-str ,state-id-str ,next-val-id-str)
         (set! init-hash
               `(hash-set ,init-hash
                          ',(string->symbol (format "state~a" state-id-str))
                          ,(simple-compile next-val-id-str)))]
        [_ (void)])))

  ;;; Make let clause defining init-hash-symbol.
  (add-expr init-hash-symbol init-hash)

  (define (compile-line line)
    ;;; Remove comments.
    (match-let* ([line (first (string-split line ";"))]
                 [(cons id-str tokens) (string-split line)]
                 [id (string->number id-str)])
      (match tokens
        [`("next" ,sort-id-str ,state-id-str ,next-val-id-str)
         ;;; A next statement determines the value of the state var that we return out.
         ;;; We build a hash map that maps state symbols (e.g. 'state0) to the expressions that convey
         ;;; the output value for the state.
         (set! output-state-hash
               `(hash-set ,output-state-hash
                          ',(hash-ref state-symbols (string->number state-id-str))
                          (signal-value ,(get-expr-id-str next-val-id-str))))]
        ;;; Do nothing. Should be handled by the above code which does a first pass for init values.
        [`("init" ,sort-id-str ,state-id-str ,val-id-str) (void)]
        [`("state" ,sort-id-str)
         ;;; It should draw from the incoming state. But how? The problem is that, with our current
         ;;; setup, i think you have to get the state value from a "nearby" signal that's also in
         ;;; context. Does there need to be some kind of top level wrapper that holds state? state can
         ;;; only be associated with values, but that doesn't make sense. what about a module that
         ;;; takes no inputs (not even a clock) and yet has a state? Does that make sense? does it make
         ;;; sense? I think that thing can only be a constant. If it doesn't take an input, there's
         ;;; nothing to trigger internal state difference. A register doesn't work without a clock. if
         ;;; you have a register, you need a clock, or the register won't function. You can have a
         ;;; combinational loop, but that doesn't really make much sense in our framework. Or, it
         ;;; could, but i guess it depends on what level we consider state changes as happening. For
         ;;; the most part, I guess it's on the callee to determine what state they care to track.

         ;;; The value is either
         ;;;
         ;;; - the lookup of the state id in the state dictionary, or
         ;;;
         ;;; - the init value, if it's not there.
         ;;;
         ;;; But what is the state dictionary? this is a context-dependent thing, isn't it?
         ;;;
         ;;; So I think there's a dict that we build up from a merger of the state values on the inputs
         ;;; to the module, and then that's the dictionary we'd use here. So if there's no inputs,
         ;;; there's no state. Does that make sense? State without input is a constant? I guess so. it
         ;;; would always be the init value, or if there's no init value...well idk.
         (let* ([state-symbol (string->symbol (format "state~a" id))])
           (hash-set! state-symbols (string->number id-str) state-symbol)
           (hash-set! state-types state-symbol (hash-ref sorts (string->number sort-id-str)))
           ;;; From the merged state formed by merging the state of all the inputs, find the state
           ;;; value by name and convert it to a signal.
           (add-expr-id-str
            id-str
            `(let* ([state-value
                     (cond
                       [(hash-has-key? ,merged-input-state-hash-symbol ',state-symbol)
                        (bv->signal (hash-ref ,merged-input-state-hash-symbol ',state-symbol))]
                       [(hash-has-key? ,init-hash-symbol ',state-symbol)
                        (bv->signal (hash-ref ,init-hash-symbol ',state-symbol))]
                       [else
                        (log-warning
                         "state ~a with no initial value, init to 0, this may not be correct in the long term"
                         ',state-symbol)
                        (bv->signal (bv 0 ,(hash-ref sorts (string->number sort-id-str))))])])
               (when (not (signal? state-value))
                 (error "Expected signal"))
               (when (not (bv? (signal-value state-value)))
                 (error "Signal value invalid"))
               state-value)))]
        [`("sort" "bitvec" ,width-str)
         (hash-set! sorts (string->number id-str) (bitvector (string->number width-str)))
         (add-expr-id-str id-str (hash-ref sorts (string->number id-str)))]
        [`("sort" "array" ,element-width-str ,index-width-str)
         (hash-set! sorts (string->number id-str) vector?)
         (add-expr-id-str id-str (hash-ref sorts (string->number id-str)))]
        ;;; Sometimes the .btor files contain inputs without names. I'm pretty sure these correspond
        ;;; either to Z or X values, or both.
        [`("input" ,type-id-str)
         (set! ins (append ins (list (string->symbol (format "unnamed-input-~a" id)))))
         (hash-set! input-types
                    (string->symbol (format "unnamed-input-~a" id))
                    (hash-ref sorts (string->number type-id-str)))
         (add-expr-id-str id-str (string->symbol (format "unnamed-input-~a" id)))]
        ;;; A named input should get a symbol representing it.
        [`("input" ,type-id-str ,name)
         (set! ins (append ins (list (string->symbol name))))
         (hash-set! input-types (string->symbol name) (hash-ref sorts (string->number type-id-str)))
         (add-expr-id-str id-str (string->symbol name))
         (add-expr merged-input-state-hash-symbol
                   `(hash-union ,merged-input-state-hash-symbol
                                (signal-state ,(string->symbol name))))]
        [`("const" ,type-id-str ,value-str)
         (let* ([type (hash-ref sorts (string->number type-id-str))]
                [value (string->number value-str 2)])
           (add-expr-id-str id-str `(bv->signal (bv ,value ,type))))]
        [`("ite" ,type-id-str ,cond-id-str ,true-val-id-str ,false-val-id-str)
         (let ([true-val (get-expr-id-str true-val-id-str)]
               [false-val (get-expr-id-str false-val-id-str)]
               [cond-val (get-expr-id-str cond-id-str)])
           (add-expr-id-str id-str
                            `(if (bitvector->bool (signal-value ,cond-val)) ,true-val ,false-val)))]
        [`("slice" ,type-id-str ,val-id-str ,u-str ,l-str)
         (let ([s (get-expr-id-str val-id-str)])
           (add-expr-id-str
            id-str
            `(signal (extract ,(string->number u-str) ,(string->number l-str) (signal-value ,s))
                     (signal-state ,s))))]
        [`("output" ,id-str ,name) (hash-set! outs (string->symbol name) (get-expr-id-str id-str))]
        [`("uext" ,out-type-id-str ,in-id-str ,_ ...)
         (let ([s (get-expr-id-str in-id-str)])
           (add-expr-id-str
            id-str
            `(bv->signal (zero-extend (signal-value ,s)
                                      ,(hash-ref sorts (string->number out-type-id-str)))
                         ,s)))]
        [`("concat" ,out-type-id-str ,a-id-str ,b-id-str)
         (let ([a (get-expr-id-str a-id-str)] [b (get-expr-id-str b-id-str)])
           (add-expr-id-str id-str (op-call-builder concat a b)))]
        [`("add" ,out-type-id-str ,a-id-str ,b-id-str)
         (let ([a (get-expr-id-str a-id-str)] [b (get-expr-id-str b-id-str)])
           (add-expr-id-str id-str (op-call-builder bvadd a b)))]
        [`("xor" ,out-type-id-str ,a-id-str ,b-id-str)
         (let ([a (get-expr-id-str a-id-str)] [b (get-expr-id-str b-id-str)])
           (add-expr-id-str id-str (op-call-builder bvxor a b)))]
        [`("and" ,out-type-id-str ,a-id-str ,b-id-str)
         (let ([a (get-expr-id-str a-id-str)] [b (get-expr-id-str b-id-str)])
           (add-expr-id-str id-str (op-call-builder bvand a b)))]
        [`("sub" ,out-type-id-str ,a-id-str ,b-id-str)
         (let ([a (get-expr-id-str a-id-str)] [b (get-expr-id-str b-id-str)])
           (add-expr-id-str id-str (op-call-builder bvsub a b)))]
        [`("or" ,out-type-id-str ,a-id-str ,b-id-str)
         (let ([a (get-expr-id-str a-id-str)] [b (get-expr-id-str b-id-str)])
           (add-expr-id-str id-str (op-call-builder bvor a b)))]
        [`("mul" ,out-type-id-str ,a-id-str ,b-id-str)
         (let ([a (get-expr-id-str a-id-str)] [b (get-expr-id-str b-id-str)])
           (add-expr-id-str id-str (op-call-builder bvmul a b)))]
        [`("srl" ,out-type-id-str ,a-id-str ,b-id-str)
         (let ([a (get-expr-id-str a-id-str)] [b (get-expr-id-str b-id-str)])
           (add-expr-id-str id-str (op-call-builder bvlshr a b)))]
        [`("not" ,out-type-id-str ,a-id-str)
         (let ([a (get-expr-id-str a-id-str)]) (add-expr-id-str id-str (op-call-builder bvnot a)))]
        [`("redor" ,out-type-id-str ,in-id-str)
         (add-expr-id-str id-str (redop-call-builder bvor (get-expr-id-str in-id-str)))]
        [`("redxor" ,out-type-id-str ,in-id-str)
         (add-expr-id-str id-str (redop-call-builder bvxor (get-expr-id-str in-id-str)))]
        [`("redand" ,out-type-id-str ,in-id-str)
         (add-expr-id-str id-str (redop-call-builder bvand (get-expr-id-str in-id-str)))]
        [`("eq" ,out-type-id-str ,a-id-str ,b-id-str)
         (let ([a (get-expr-id-str a-id-str)] [b (get-expr-id-str b-id-str)])
           (add-expr-id-str id-str (compop-call-builder bveq a b)))]
        [`("neq" ,out-type-id-str ,a-id-str ,b-id-str)
         (let ([a (get-expr-id-str a-id-str)] [b (get-expr-id-str b-id-str)])
           (add-expr-id-str id-str (compop-call-builder `(compose1 not bveq) a b)))])))

  (for ([line (filter (lambda (line) (not (equal? #\; (string-ref line 0))))
                      (string-split str #rx"\n+"))])
    (compile-line line))

  ;;; Makes a function which outputs the given expression.
  (define/contract
   (make-function out-symbol)
   (-> symbol? (list/c any/c any/c))
   ;;; The contract for our function
   (define contract
     `(->* ()
           ;;; apply append == flatten1 (flatten flattens recursively)
           (,@(apply append
                     (for/list ([input ins])
                       (let* ([type (hash-ref input-types input)])
                         (list (string->keyword (symbol->string input))
                               `(struct/c signal ,type (hash/c symbol? bv?)))))))
           (struct/c signal bv? hash?)))
   (define function
     `(λ (,@(apply append
                   (for/list ([input ins])
                     (let* ([type (hash-ref input-types input)])
                       (list (string->keyword (symbol->string input))
                             `[,input
                               ,(match default-value
                                  ['symbolic
                                   `(bv->signal (constant (list ',input 'symbolic-constant)
                                                          ,type))])])))))
        (let* (,@let*-clauses)
          ;;; We output the expression corresponding to out-symbol, but we wrap it in a new signal
          ;;; with the updated state.
          (signal (signal-value ,(hash-ref outs out-symbol)) ,output-state-hash))))
   (list function contract))

  ;;; Instead of using make-function to make a function for each output, we make a single function
  ;;; which returns all outputs in a map.
  (define out-function
    `(λ (,@(apply append
                  (for/list ([input ins])
                    (let* ([type (hash-ref input-types input)])
                      (list (string->keyword (symbol->string input))
                            `[,input
                              ,(match default-value
                                 ['symbolic
                                  `(bv->signal (constant (list ',input 'symbolic-constant)
                                                         ,type))])])))))
       (let* (,@let*-clauses)
         ;;; We output the expression corresponding to out-symbol, but we wrap it in a new signal
         ;;; with the updated state.
         (make-immutable-hash (list ,@(map (lambda (k v) `(cons ,k ,v))
                                           (map (λ (s) `(quote ,s)) (hash-keys outs))
                                           (map (lambda (out-symbol)
                                                  `(signal (signal-value ,(hash-ref outs out-symbol))
                                                           ,output-state-hash))
                                                (hash-keys outs))))))))

  (define requires
    (list (format "(require (file \"~a\"))" stateful-design-experiment-runtime-path)
          "(require rosette)"
          "(require racket/hash)"))

  (list out-function requires))

;;; Expressions all have signal values.
;;;
;;; expr: Expression to be interpreted.
;;;
;;; env: Maps symbols to expressions.
;;;
;;; init: Maps symbols to bitvectors. Initial values of states.
(define (new-interpreter expr env init)
  (define memo-hash (make-hash))

  (define (new-interpreter expr env init)
    (if (hash-has-key? memo-hash expr)
        (hash-ref memo-hash expr)
        (begin
          (define out
            (match expr
              [`(set-state ,signal-expr ,(? hash? state-hash))
               (let* ([s (new-interpreter signal-expr env init)]
                      [new-state
                       (foldl (λ (k new-state)
                                (hash-set new-state
                                          k
                                          (signal-value
                                           (new-interpreter (hash-ref state-hash k) env init))))
                              (hash)
                              (hash-keys state-hash))])
                 (signal (signal-value s) new-state))]
              ;;; Get a state value from the merged states of the provided list of signals. Otherwise, use
              ;;; the initial value of the state.
              ;;;
              ;;; We can also implement this for the case of a single signal expr, I just haven't needed it
              ;;; yet.
              ;;;
              ;;; Returns the value of the state as a signal without any state attached.
              [`(get-state ,(? list? signal-exprs-list) ,(? symbol? state-symbol))
               (let* ([signals-list (map (λ (signal-expr) (new-interpreter signal-expr env init))
                                         signal-exprs-list)]
                      [merged-state (merge-state signals-list)]
                      [state-value
                       (if (hash-has-key? merged-state state-symbol)
                           ;;; TODO this seems kinda messy: if the state is in the merged-state hashtable,
                           ;;; it's a bv; if it's not and we have to resort to init, then it's a signal. If
                           ;;; it's a bv, we have to convert it to signal. Feels like the types aren't
                           ;;; lining up cleanly.
                           (bv->signal (hash-ref merged-state state-symbol))
                           (hash-ref init state-symbol))])
                 (when (not (signal? state-value))
                   (error "Expected signal"))
                 (when (not (bv? (signal-value state-value)))
                   (error "Signal value invalid"))
                 state-value)]

              [`(if ,cond-expr ,true-expr ,false-expr)
               (if (bitvector->bool (signal-value (new-interpreter cond-expr env init)))
                   (new-interpreter true-expr env init)
                   (new-interpreter false-expr env init))]
              [`(bveq ,a ,b)
               (let* ([a (new-interpreter a env init)] [b (new-interpreter b env init)])
                 (signal (bool->bitvector (bveq (signal-value a) (signal-value b)))
                         (merge-state (list a b))))]
              [`(bvadd ,a ,b)
               (let* ([a (new-interpreter a env init)] [b (new-interpreter b env init)])
                 (signal (bvadd (signal-value a) (signal-value b)) (merge-state (list a b))))]
              [`(bvand ,a ,b)
               (let* ([a (new-interpreter a env init)] [b (new-interpreter b env init)])
                 (signal (bvand (signal-value a) (signal-value b)) (merge-state (list a b))))]
              [`(bvor ,a ,b)
               (let* ([a (new-interpreter a env init)] [b (new-interpreter b env init)])
                 (signal (bvor (signal-value a) (signal-value b)) (merge-state (list a b))))]
              [`(bvxor ,a ,b)
               (let* ([a (new-interpreter a env init)] [b (new-interpreter b env init)])
                 (signal (bvxor (signal-value a) (signal-value b)) (merge-state (list a b))))]
              [`(bvmul ,a ,b)
               (let* ([a (new-interpreter a env init)] [b (new-interpreter b env init)])
                 (signal (bvmul (signal-value a) (signal-value b)) (merge-state (list a b))))]
              [`(bvsub ,a ,b)
               (let* ([a (new-interpreter a env init)] [b (new-interpreter b env init)])
                 (signal (bvsub (signal-value a) (signal-value b)) (merge-state (list a b))))]
              [`(bvnot ,a)
               (let* ([a (new-interpreter a env init)])
                 (signal (bvnot (signal-value a)) (signal-state a)))]
              [(lr:zero-extend val type)
               (let* ([val (new-interpreter val env init)] [type (new-interpreter type env init)])
                 (bv->signal (zero-extend (signal-value val) type) val))]
              [(lr:concat (list a b))
               (let* ([a (new-interpreter a env init)] [b (new-interpreter b env init)])
                 (signal (concat (signal-value a) (signal-value b)) (merge-state (list a b))))]
              [(lr:extract hi lo sig)
               (let* ([sig (new-interpreter sig env init)])
                 (signal (extract hi lo (signal-value sig)) (signal-state sig)))]
              [`(redor ,a)
               (let* ([a (new-interpreter a env init)])
                 (signal (apply bvor (bitvector->bits (signal-value a))) (signal-state a)))]
              [`(redand ,a)
               (let* ([a (new-interpreter a env init)])
                 (signal (apply bvand (bitvector->bits (signal-value a))) (signal-state a)))]
              [`(redxor ,a)
               (let* ([a (new-interpreter a env init)])
                 (signal (apply bvxor (bitvector->bits (signal-value a))) (signal-state a)))]
              [(? signal?) expr]
              [(? symbol?) (hash-ref env expr)]
              [(? integer? n) n]
              [(? bitvector?) expr]))
          (hash-set! memo-hash expr out)

          out)))

  (new-interpreter expr env init))

(module+ test
  (require racket/hash
           racket/contract)

  (test-case
   "Parse and verify a stateful design"
   (begin

     (match-define (list '(clk rst)
                         (hash-table ('out out-expr))
                         init
                         next
                         state-symbols
                         state-types
                         input-types)
       (parse-btor-new
        #<<here-string-delimiter
1 sort bitvec 1
2 input 1 clk
3 input 1 rst
4 sort bitvec 8
5 const 4 00000000
6 state 4
7 init 4 6 5
8 state 4
9 init 4 8 5
10 const 1 1
11 state 1
12 init 1 11 10
13 sort bitvec 2
14 concat 13 2 11
15 const 13 10
16 eq 1 14 15
17 ite 4 16 8 6
18 output 17 out
19 uext 4 10 7
20 add 4 17 19
21 uext 4 20 0 counter_incremented
22 uext 4 17 0 counter_reg
23 next 4 6 17
24 ite 4 3 5 20
25 next 4 8 24
26 next 1 11 2
here-string-delimiter
        ;
        ))
     (let* ([o0 (new-interpreter out-expr
                                 (hash 'clk (bv->signal (bv 0 1)) 'rst (bv->signal (bv 0 1)))
                                 init)]
            [o1 (new-interpreter out-expr
                                 (hash 'clk (bv->signal (bv 1 1) o0) 'rst (bv->signal (bv 0 1) o0))
                                 init)]
            [o2 (new-interpreter out-expr
                                 (hash 'clk (bv->signal (bv 0 1) o1) 'rst (bv->signal (bv 0 1) o1))
                                 init)]
            [o3 (new-interpreter out-expr
                                 (hash 'clk (bv->signal (bv 1 1) o2) 'rst (bv->signal (bv 0 1) o2))
                                 init)]
            [o4 (new-interpreter out-expr
                                 (hash 'clk (bv->signal (bv 0 1) o3) 'rst (bv->signal (bv 0 1) o3))
                                 init)]
            [o5 (new-interpreter out-expr
                                 (hash 'clk (bv->signal (bv 1 1) o4) 'rst (bv->signal (bv 0 1) o4))
                                 init)]
            [o6 (new-interpreter out-expr
                                 (hash 'clk (bv->signal (bv 0 1) o5) 'rst (bv->signal (bv 0 1) o5))
                                 init)]
            [o7 (new-interpreter out-expr
                                 (hash 'clk (bv->signal (bv 1 1) o6) 'rst (bv->signal (bv 0 1) o6))
                                 init)])
       (check-equal? (signal-value o0) (bv 0 8))
       (check-equal? (signal-value o1) (bv 1 8))
       (check-equal? (signal-value o2) (bv 1 8))
       (check-equal? (signal-value o3) (bv 2 8))
       (check-equal? (signal-value o4) (bv 2 8))
       (check-equal? (signal-value o5) (bv 3 8))
       (check-equal? (signal-value o6) (bv 3 8))
       (check-equal? (signal-value o7) (bv 4 8))))))

(module+ test
  (require rosette/lib/synthax)
  (define-runtime-path dsp-btor-file "DSP48E2.btor")

  ;;; TODO need to make the test more robust, i.e. check it against the DSP file.
  (test-case "Parse DSP48E2" (check-not-exn (thunk (parse-btor-new (file->string dsp-btor-file))))))
