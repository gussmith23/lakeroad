#lang racket/base
;;; Utilities for .btor files.

(provide btor->racket)

(require racket/runtime-path
         racket/match
         racket/list
         racket/string)

;;; Runtime path of the signal.rkt file, needed for writing Racket code.
(define-runtime-path stateful-design-experiment-runtime-path "signal.rkt")

;;; Takes a btor file as a string.
;;;
;;; default-value: All input values are assumed to be optional. This argument controls the default
;;; value for each input. 'symbolic means default arguments will be symbolic bitvectors wrapped in
;;; signals.
;;;
;;; Returns:
;;; - A function representing the btor file. The function returns a map, mapping output symbols to
;;;   their values.
;;; - A list of strings representing the requires needed for the generated code.
;;;
;;; TODO(@gussmith): We rely heavily on hash tables for this implementation. Hash tables are not
;;; lifted in Rosette, and thus we have to be very careful with them. In general, I think these are
;;; the rules to obey when using hash tables in Rosette:
;;; - Only use immutable hash tables.
;;; - Keys should never be symbolic. They should always be concrete.
(define (btor->racket str #:default-value [default-value 'symbolic])

  ;;; Generates an expression that represents a key used for indexing the state hash. Keys are formed
  ;;; by appending the `name` argument of the semantics function to a state name, e.g. "state10".
  (define (make-state-key-expr state-symbol)
    `(string->symbol (string-append name ,(symbol->string state-symbol))))

  ;;; Input signals.
  (define ins (list))

  ;;; Outputs. Maps name (string) to id in h of the expression defining the output.
  (define outs (make-hash))

  ;;; Maps IDs (integers) to state symbols.
  (define state-symbols (make-hash))

  ;;; Maps state symbols to state types (bitvector?).
  (define state-types (make-hash))

  ;;; Maps input symbol to type.
  (define input-types (make-hash))

  ;;; Maps btor id (generated by btor-id-str->id) to (bitvector?) type.
  (define sorts (make-hash))

  ;;; Helper for generating code for computing an op over signal arguments. Converts the args to bvs,
  ;;; computes the op, and then converts back to signal.
  (define (op-call-builder op . signal-exprs)
    (let ([signal-vals (map (Î» (signal-expr) `(signal-value ,signal-expr)) signal-exprs)])
      `(signal
        (,op ,@signal-vals)
        ;;; TODO(@gussmith23): I'm disabling state on these internal variables, because I actually think
        ;;; it's entirely unnecessary here.
        ;
        ;(merge-state (list ,@signal-exprs))
        (list))))

  ;;; Reduction op builder helper.
  (define (redop-call-builder op signal-expr)
    `(signal (apply ,op (bitvector->bits (signal-value ,signal-expr))) (signal-state ,signal-expr)))

  ;;; Comparison op builder helper.
  (define (compop-call-builder op . signal-exprs)
    (let ([signal-vals (map (Î» (signal-expr) `(signal-value ,signal-expr)) signal-exprs)])
      `(signal
        (bool->bitvector (,op ,@signal-vals))
        ;;; TODO(@gussmith23): I'm disabling state on these internal variables, because I actually think
        ;;; it's entirely unnecessary here.
        ;
        ;(merge-state (list ,@signal-exprs))
        (list))))

  (define (id-str-to-btor-id id-str)
    (string->symbol (format "btor~a" id-str)))
  ;;; Maps a btor-id (as an integer) to the expression for that id.
  (define let*-clauses (list))
  (define (add-expr symbol expr)
    (set! let*-clauses (append let*-clauses (list `[,symbol ,expr]))))
  (define (add-expr-id-str id-str expr)
    (add-expr (id-str-to-btor-id id-str) expr))
  (define (get-expr-id-str id-str)
    (id-str-to-btor-id id-str))

  ;;; The expression representing the initial state values hash.
  (define init-hash '(list))
  ;;; The symbol to which the above init hash expression will be bound via a let clause.
  (define init-hash-symbol 'init-hash)

  ;;; The expression representing the merged state
  (define merged-input-state-hash '(list))
  (define merged-input-state-hash-symbol 'merged-input-state-hash)
  ;;; Add initial (empty) input state hash.
  (add-expr merged-input-state-hash-symbol merged-input-state-hash)

  ;;; The expression for the output state hash.
  (define output-state-hash '(list))

  ;;; When a state is not in the state hash, we use these functions to get an initial value.
  ;;;
  ;;; Maps id (integer) of a sort expression to a function that returns a default value for that sort.
  (define get-default-value-fn-hash (make-hash))

  ;;; Annoyingly, initial state values are defined at the end of btor files, but we need the init
  ;;; values at the beginning. So we do a first pass to compile the init values.

  ;;; Given an btor-id in string form, returns a bv? expression representing that btor id.
  ;;; Used only for initial state preprocessing.
  (define (simple-compile btor-id-str)
    ;;; Find the line that equals
    (define matching-lines
      (filter
       (lambda (line)
         (match-let* ;;; Remove comments.
             ([line (first (string-split line ";"))] [(cons id-str tokens) (string-split line)])
           (equal? id-str btor-id-str)))
       ;; Split file into lines and filter empty lines.
       (filter (lambda (line) (not (equal? #\; (string-ref line 0)))) (string-split str #rx"\n+"))))

    (when (not (equal? (length matching-lines) 1))
      (error "expected exactly 1 match"))

    ;;; Remove comments.
    (match-let* ([line (first matching-lines)]
                 [line (first (string-split line ";"))]
                 [(cons id-str tokens) (string-split line)]
                 [id (string->number id-str)])
      (match tokens
        [`("sort" "bitvec" ,bw-str) `(bitvector ,(string->number bw-str))]
        [`("const" ,sort-id-str ,value-str)
         `(bv ,(string->number value-str 2) ,(simple-compile sort-id-str))])))

  ;;; First pass to compile init values.
  (for ([line (filter (lambda (line) (not (equal? #\; (string-ref line 0))))
                      (string-split str #rx"\n+"))])
    ;;; Remove comments.
    (match-let* ([line (first (string-split line ";"))]
                 [(cons id-str tokens) (string-split line)]
                 [id (string->number id-str)])
      (match tokens
        [`("init" ,sort-id-str ,state-id-str ,next-val-id-str)
         (set! init-hash
               `(append (list (cons ,(make-state-key-expr (string->symbol (format "state~a"
                                                                                  state-id-str)))
                                    ,(simple-compile next-val-id-str)))
                        ,init-hash))]
        [_ (void)])))

  ;;; Make let clause defining init-hash-symbol.
  (add-expr init-hash-symbol init-hash)

  (define (compile-line line)
    ;;; Remove comments.
    (match-let* ([line (first (string-split line ";"))]
                 [(cons id-str tokens) (string-split line)]
                 [id (string->number id-str)])
      (match tokens
        [`("read" ,sort-id-str ,array-id-str ,index-id-str)
         (let ([array (get-expr-id-str array-id-str)] [index (get-expr-id-str index-id-str)])
           (add-expr-id-str id-str
                            `(signal (vector-ref-bv (signal-value ,array) (signal-value ,index))
                                     (merge-state (list ,array ,index)))))]
        [`("write" ,sort-id-str ,array-id-str ,index-id-str ,value-id-str)
         (let ([array (get-expr-id-str array-id-str)]
               [index (get-expr-id-str index-id-str)]
               [value (get-expr-id-str value-id-str)])
           (add-expr-id-str
            id-str
            `(begin
               (vector-set!-bv (signal-value ,array) (signal-value ,index) (signal-value ,value))
               (signal (signal-value ,array) (merge-state (list ,array ,index ,value))))))]
        ;;; `next` can optionally have a name associated with it.
        [`("next" ,sort-id-str ,state-id-str ,next-val-id-str ,maybe-name-str ...)
         ;;; Check that there's at most one name.
         (when (> (length maybe-name-str) 1)
           (error "expected three or four arguments to 'next', but got ~a" tokens))

         ;;; If the name is set, make sure it matches the name we originally gave the state.
         (when (and (equal? (length maybe-name-str) 1)
                    (not (equal? (string->symbol (first maybe-name-str))
                                 (hash-ref state-symbols (string->number state-id-str)))))
           (error "setting state with name ~a but reassigning with new name ~a"
                  (first maybe-name-str)
                  (hash-ref state-symbols (string->number state-id-str))))

         ;;; A next statement determines the value of the state var that we return out.
         ;;; We build a hash map that maps state symbols (e.g. 'state0) to the expressions that convey
         ;;; the output value for the state.
         (set!
          output-state-hash
          `(append
            (list (cons ,(make-state-key-expr (hash-ref state-symbols (string->number state-id-str)))
                        (cons (signal-value ,(get-expr-id-str next-val-id-str))
                              ;;; New version is either old version + 1, or 0 if it wasn't in the
                              ;;; hash.
                              (if (assoc-has-key? ,merged-input-state-hash-symbol
                                                  ,(make-state-key-expr
                                                    (hash-ref state-symbols
                                                              (string->number state-id-str))))
                                  (add1 (cdr (assoc-ref ,merged-input-state-hash-symbol
                                                        ,(make-state-key-expr
                                                          (hash-ref state-symbols
                                                                    (string->number state-id-str))))))
                                  0))))
            ,output-state-hash))]
        ;;; Do nothing. Should be handled by the above code which does a first pass for init values.
        [`("init" ,sort-id-str ,state-id-str ,val-id-str) (void)]
        ;;; `name` is optional. We approximate optional using `...`, which will match whatever's left.
        ;;; Then we can check whether `name` has length 0 or 1.
        [`("state" ,sort-id-str ,name ...)
         (when (not (or (equal? (length name) 0) (equal? (length name) 1)))
           (error "expected 1 or 2 arguments to 'state', but go ~a" tokens))

         ;;; It should draw from the incoming state. But how? The problem is that, with our current
         ;;; setup, i think you have to get the state value from a "nearby" signal that's also in
         ;;; context. Does there need to be some kind of top level wrapper that holds state? state can
         ;;; only be associated with values, but that doesn't make sense. what about a module that
         ;;; takes no inputs (not even a clock) and yet has a state? Does that make sense? does it make
         ;;; sense? I think that thing can only be a constant. If it doesn't take an input, there's
         ;;; nothing to trigger internal state difference. A register doesn't work without a clock. if
         ;;; you have a register, you need a clock, or the register won't function. You can have a
         ;;; combinational loop, but that doesn't really make much sense in our framework. Or, it
         ;;; could, but i guess it depends on what level we consider state changes as happening. For
         ;;; the most part, I guess it's on the callee to determine what state they care to track.

         ;;; The value is either
         ;;;
         ;;; - the lookup of the state id in the state dictionary, or
         ;;;
         ;;; - the init value, if it's not there.
         ;;;
         ;;; But what is the state dictionary? this is a context-dependent thing, isn't it?
         ;;;
         ;;; So I think there's a dict that we build up from a merger of the state values on the inputs
         ;;; to the module, and then that's the dictionary we'd use here. So if there's no inputs,
         ;;; there's no state. Does that make sense? State without input is a constant? I guess so. it
         ;;; would always be the init value, or if there's no init value...well idk.
         ;;;
         ;;; The symbol for this state is given a default name unless the name is provided.
         (let* ([state-symbol (if (equal? (length name) 1)
                                  (string->symbol (first name))
                                  (string->symbol (format "state~a" id)))])
           (hash-set! state-symbols (string->number id-str) state-symbol)
           (hash-set! state-types state-symbol (hash-ref sorts (string->number sort-id-str)))
           ;;; From the merged state formed by merging the state of all the inputs, find the state
           ;;; value by name and convert it to a signal.
           (add-expr-id-str
            id-str
            `(let* ([state-value
                     (cond
                       [(assoc-has-key? ,merged-input-state-hash-symbol
                                        ,(make-state-key-expr state-symbol))
                        ;;; The state list holds (key . (value . version)) pairs. Get the value once
                        ;;; we find the (value . version) pair.
                        (bv->signal (car (assoc-ref ,merged-input-state-hash-symbol
                                                    ,(make-state-key-expr state-symbol))))]
                       [(assoc-has-key? ,init-hash-symbol ,(make-state-key-expr state-symbol))
                        (bv->signal (assoc-ref ,init-hash-symbol
                                               ,(make-state-key-expr state-symbol)))]
                       [else
                        (bv->signal (,(hash-ref get-default-value-fn-hash
                                                (string->number sort-id-str))))])])
               (when (not (signal? state-value))
                 (error "Expected signal"))
               ;;; TODO(@gussmith23): Signals don't just have to contain bvs, now that we've enabled
               ;;; arrays.
               ;;;  (when (not (bv? (signal-value state-value)))
               ;;;    (error "Signal value invalid"))
               state-value)))]
        [`("sort" "bitvec" ,width-str)
         (hash-set! sorts (string->number id-str) `(bitvector ,(string->number width-str)))
         (add-expr-id-str id-str (hash-ref sorts (string->number id-str)))
         (hash-set!
          get-default-value-fn-hash
          (string->number id-str)
          `(lambda ()
             (log-warning "Getting default value of 0 for bitvector, this may be a bad idea!")
             (bv 0 ,(string->number width-str))))]
        [`("sort" "array" ,index-sort-id-str ,element-sort-id-str)
         (hash-set! sorts (string->number id-str) 'vector?)
         (add-expr-id-str id-str (hash-ref sorts (string->number id-str)))
         (hash-set!
          get-default-value-fn-hash
          (string->number id-str)
          `(lambda ()
             (log-warning "Getting default value array of 0s for array, this may be a bad idea!")
             (make-vector (expt 2 (bitvector-size ,(id-str-to-btor-id index-sort-id-str)))
                          (bv 0 (bitvector-size ,(id-str-to-btor-id element-sort-id-str))))))]
        ;;; Sometimes the .btor files contain inputs without names. I'm pretty sure these correspond
        ;;; either to Z or X values, or both.
        [`("input" ,type-id-str)
         (set! ins (append ins (list (string->symbol (format "unnamed-input-~a" id)))))
         (hash-set! input-types
                    (string->symbol (format "unnamed-input-~a" id))
                    (hash-ref sorts (string->number type-id-str)))
         (add-expr-id-str id-str (string->symbol (format "unnamed-input-~a" id)))]
        ;;; A named input should get a symbol representing it.
        [`("input" ,type-id-str ,name)
         (set! ins (append ins (list (string->symbol name))))
         (hash-set! input-types (string->symbol name) (hash-ref sorts (string->number type-id-str)))
         (add-expr-id-str id-str (string->symbol name))
         (add-expr merged-input-state-hash-symbol
                   `(merge-states ,merged-input-state-hash-symbol
                                  (signal-state ,(string->symbol name))))]
        [`("const" ,type-id-str ,value-str)
         (let* ([type (hash-ref sorts (string->number type-id-str))]
                [value (string->number value-str 2)])
           (add-expr-id-str id-str `(bv->signal (bv ,value ,type))))]
        [`("ite" ,type-id-str ,cond-id-str ,true-val-id-str ,false-val-id-str)
         (let ([true-val (get-expr-id-str true-val-id-str)]
               [false-val (get-expr-id-str false-val-id-str)]
               [cond-val (get-expr-id-str cond-id-str)])
           (add-expr-id-str id-str
                            `(if (bitvector->bool (signal-value ,cond-val)) ,true-val ,false-val)))]
        [`("slice" ,type-id-str ,val-id-str ,u-str ,l-str)
         (let ([s (get-expr-id-str val-id-str)])
           (add-expr-id-str
            id-str
            `(signal (extract ,(string->number u-str) ,(string->number l-str) (signal-value ,s))
                     (signal-state ,s))))]
        [`("output" ,id-str ,name) (hash-set! outs (string->symbol name) (get-expr-id-str id-str))]
        [`("uext" ,out-type-id-str ,in-id-str ,_ ...)
         (let ([s (get-expr-id-str in-id-str)])
           (add-expr-id-str id-str
                            `(bv->signal (zero-extend (signal-value ,s)
                                                      ,(hash-ref sorts
                                                                 (string->number out-type-id-str)))
                                         ,s)))]
        [`("sext" ,out-type-id-str ,in-id-str ,_ ...)
         (let ([s (get-expr-id-str in-id-str)])
           (add-expr-id-str id-str
                            `(bv->signal (sign-extend (signal-value ,s)
                                                      ,(hash-ref sorts
                                                                 (string->number out-type-id-str)))
                                         ,s)))]
        [`("concat" ,out-type-id-str ,a-id-str ,b-id-str)
         (let ([a (get-expr-id-str a-id-str)] [b (get-expr-id-str b-id-str)])
           (add-expr-id-str id-str (op-call-builder 'concat a b)))]
        [`("add" ,out-type-id-str ,a-id-str ,b-id-str)
         (let ([a (get-expr-id-str a-id-str)] [b (get-expr-id-str b-id-str)])
           (add-expr-id-str id-str (op-call-builder 'bvadd a b)))]
        [`("xor" ,out-type-id-str ,a-id-str ,b-id-str)
         (let ([a (get-expr-id-str a-id-str)] [b (get-expr-id-str b-id-str)])
           (add-expr-id-str id-str (op-call-builder 'bvxor a b)))]
        [`("and" ,out-type-id-str ,a-id-str ,b-id-str)
         (let ([a (get-expr-id-str a-id-str)] [b (get-expr-id-str b-id-str)])
           (add-expr-id-str id-str (op-call-builder 'bvand a b)))]
        [`("sub" ,out-type-id-str ,a-id-str ,b-id-str)
         (let ([a (get-expr-id-str a-id-str)] [b (get-expr-id-str b-id-str)])
           (add-expr-id-str id-str (op-call-builder 'bvsub a b)))]
        [`("or" ,out-type-id-str ,a-id-str ,b-id-str)
         (let ([a (get-expr-id-str a-id-str)] [b (get-expr-id-str b-id-str)])
           (add-expr-id-str id-str (op-call-builder 'bvor a b)))]
        [`("mul" ,out-type-id-str ,a-id-str ,b-id-str)
         (let ([a (get-expr-id-str a-id-str)] [b (get-expr-id-str b-id-str)])
           (add-expr-id-str id-str (op-call-builder 'bvmul a b)))]
        [`("srl" ,out-type-id-str ,a-id-str ,b-id-str)
         (let ([a (get-expr-id-str a-id-str)] [b (get-expr-id-str b-id-str)])
           (add-expr-id-str id-str (op-call-builder 'bvlshr a b)))]
        [`("not" ,out-type-id-str ,a-id-str)
         (let ([a (get-expr-id-str a-id-str)]) (add-expr-id-str id-str (op-call-builder 'bvnot a)))]
        [`("neg" ,_ ,a-id-str)
         (let ([a (get-expr-id-str a-id-str)]) (add-expr-id-str id-str (op-call-builder 'bvneg a)))]
        [`("xnor" ,out-type-id-str ,a-id-str ,b-id-str)
         (let ([a (get-expr-id-str a-id-str)] [b (get-expr-id-str b-id-str)])
           (add-expr-id-str id-str (op-call-builder '(lambda (a b) (bvnot (bvxor a b))) a b)))]
        [`("redor" ,out-type-id-str ,in-id-str)
         (add-expr-id-str id-str (redop-call-builder 'bvor (get-expr-id-str in-id-str)))]
        [`("redxor" ,out-type-id-str ,in-id-str)
         (add-expr-id-str id-str (redop-call-builder 'bvxor (get-expr-id-str in-id-str)))]
        [`("redand" ,out-type-id-str ,in-id-str)
         (add-expr-id-str id-str (redop-call-builder 'bvand (get-expr-id-str in-id-str)))]
        [`("eq" ,out-type-id-str ,a-id-str ,b-id-str)
         (let ([a (get-expr-id-str a-id-str)] [b (get-expr-id-str b-id-str)])
           (add-expr-id-str id-str (compop-call-builder 'bveq a b)))]
        [`("ugte" ,out-type-id-str ,a-id-str ,b-id-str)
         (let ([a (get-expr-id-str a-id-str)] [b (get-expr-id-str b-id-str)])
           (add-expr-id-str id-str (compop-call-builder 'bvuge a b)))]
        [`("neq" ,out-type-id-str ,a-id-str ,b-id-str)
         (let ([a (get-expr-id-str a-id-str)] [b (get-expr-id-str b-id-str)])
           (add-expr-id-str id-str (compop-call-builder `(compose1 not bveq) a b)))])))

  (for ([line (filter (lambda (line) (not (equal? #\; (string-ref line 0))))
                      (string-split str #rx"\n+"))])
    (compile-line line))

  ;;; The final output state hash will be all of the new states appended to all of the state data that
  ;;; came in to the function.
  ;;; TODO(@gussmith23): This may be slow/take up a lot of memory.
  ;;;
  ;;; It IS slow! Trying to mitigate by removing duplicates.
  (set!
   output-state-hash
   `(remove-duplicates (append ,output-state-hash ,merged-input-state-hash-symbol) equal? #:key car))

  ;;; Generate output function.
  (define out-function
    `(Î» (,@(apply append
                  (for/list ([input ins])
                    (let* ([type (hash-ref input-types input)])
                      (list (string->keyword (symbol->string input))
                            `[,input
                              ,(match default-value
                                 ['symbolic `(bv->signal (constant ',input ,type))])]))))
         #:name [name ""])
       (let* (,@let*-clauses [output-state ,output-state-hash])
         ;;; We output the expression corresponding to out-symbol, but we wrap it in a new signal
         ;;; with the updated state.
         (list ,@(map (lambda (k v) `(cons ,k ,v))
                      (map (Î» (s) `(quote ,s)) (hash-keys outs))
                      (map (lambda (out-symbol)
                             `(signal (signal-value ,(hash-ref outs out-symbol)) output-state))
                           (hash-keys outs)))))))

  (define requires
    (list (format "(require (file \"~a\"))" stateful-design-experiment-runtime-path)
          "(require rosette)"))

  (list out-function requires))

(module+ test
  (require rackunit
           "signal.rkt")
  (define-namespace-anchor a)
  (test-case "Zach Sisco's TOGA test"
    (begin
      (match-define (list function-syntax contract-syntax)
        (btor->racket #<<here-string-delimiter
; BTOR description generated by Yosys 0.21+10 (git sha1 558018522, clang 14.0.0 -fPIC -Os) for module toga.
1 sort bitvec 1
2 input 1 clk ; toga.v:1.19-1.22
3 input 1 reset ; toga.v:1.30-1.35
4 sort bitvec 4
5 state 4
6 state 4
7 const 1 1
8 state 1
9 init 1 8 7
10 sort bitvec 2
11 concat 10 2 8
12 const 10 10
13 eq 1 11 12
14 ite 4 13 6 5
15 output 14 pc ; toga.v:1.50-1.52
16 sort bitvec 8
17 sort array 4 16
18 state 17 pm
19 read 16 18 14
20 slice 4 19 3 0
21 uext 4 20 0 a_addr ; toga.v:25.11-25.17
22 sort array 4 1
23 state 22 dm
24 state 4
25 state 1
26 const 1 0
27 state 1
28 state 1
29 init 1 28 7
30 concat 10 2 28
31 eq 1 30 12
32 ite 1 31 27 26
33 read 1 23 24
34 not 1 32
35 and 1 33 34
36 and 1 25 32
37 or 1 36 35
38 write 22 23 24 37
39 redor 1 32
40 ite 22 39 38 23
41 read 1 40 20
42 next 22 23 40
43 not 1 41
44 uext 1 43 0 a_toggle ; toga.v:27.6-27.14
45 slice 4 19 7 4
46 uext 4 45 0 b_addr ; toga.v:26.11-26.17
47 uext 16 19 0 instruction ; toga.v:24.11-24.22
48 next 4 5 14
49 uext 4 7 3
50 add 4 14 49
51 ite 4 41 50 45
52 const 4 0000
53 ite 4 3 52 51
54 next 4 6 53
55 next 1 8 2
56 next 4 24 20
57 next 1 25 43
58 next 1 27 7
59 next 1 28 2
60 next 17 18 18 pm ; toga.v:20.10-20.12
; end of yosys output
here-string-delimiter
                      ;
                      ))

      (define ns (namespace-anchor->namespace a))
      (namespace-require 'rosette ns)
      (define toga-f (eval function-syntax ns))
      ;;;(pretty-write function-syntax)

      (test-not-exn "toga runs without exception" (lambda () (toga-f))))))
