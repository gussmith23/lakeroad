;;; Lakeroad language definition, for importing before running other tests.

; Ops
(datatype Op
  (And)
  (Or)
  (Xor)
  (Shr)
  ; Returns a bitvector of width 1.
  (Eq)
  (LogicNot)
  ; (Mux select-expr expr expr)
  (Mux))

; Sketch Ops
(datatype SketchOp
  (LUT4))

; Our language. Note that we do not explicitly use IDs as in the Lakeroad paper
; formalization. The IDs are still there, though: they're the 
; eclass IDs!
(datatype Expr
  ; (BV value bitwidth)
  (BV i64 i64)
  ; (Var name bitwidth)
  (Var String i64)
  ; (OpN op input-expr...)
  (Op1 Op Expr :cost 100000000)
  (Op2 Op Expr Expr :cost 100000000)
  (Op3 Op Expr Expr Expr :cost 100000000)
  ; (Reg default-value clock-expr d-expr)
  (Reg i64 Expr Expr)
  ; (Wire name bitwidth)
  ; Wire is a placeholder for another expression. See below how 
  ; wires are the key to creating cyclic graphs.
  (Wire String i64)
  ; (Extract high low expr)
  ; Extracts expr[high:low] using inclusive ranges as in Rosette/Verilog.
  (Extract i64 i64 Expr)
  ; (Concat expr expr)
  (Concat Expr Expr)
  ; (ZeroExtend expr bitwidth)
  (ZeroExtend Expr i64)
  
  ; (Sketch sketch-id input-expr...)
  ; A sketch node. This is a proposal for a potential expression, that will
  ; need to be solved for/made concrete later on.
  (Sketch1 SketchOp Expr)
  (Sketch2 SketchOp Expr Expr)
  (Sketch3 SketchOp Expr Expr Expr)
  (Sketch4 SketchOp Expr Expr Expr Expr)
  )

;;; Types for Lakeroad expressions.
(datatype Type
  ;;; Bitvector type.
  (Bitvector i64))

;;; Indicates that a Lakeroad expression has a given type.
(relation HasType (Expr Type))

;;; Typing judgements.
(ruleset typing)
(rule
  ((Wire name bw))
  ((HasType (Wire name bw) (Bitvector bw)))
  :ruleset typing)
(rule
  ((Var name bw))
  ((HasType (Var name bw) (Bitvector bw)))
  :ruleset typing)
(rule
  ((BV name bw))
  ((HasType (BV name bw) (Bitvector bw)))
  :ruleset typing)
(rule
  ((Reg default clk-expr d-expr)
   ; Currently require clock to be one bit.
   (HasType clk-expr (Bitvector 1))
   (HasType d-expr (Bitvector bw)))
  ((HasType (Reg default clk-expr d-expr) (Bitvector bw)))
  :ruleset typing)
(rule
  ((Op2 (And) a-expr b-expr)
   (HasType a-expr (Bitvector bw))
   (HasType b-expr (Bitvector bw)))
  ((HasType (Op2 (And) a-expr b-expr) (Bitvector bw)))
  :ruleset typing)
(rule
  ((Op2 (Or) a-expr b-expr)
   (HasType a-expr (Bitvector bw))
   (HasType b-expr (Bitvector bw)))
  ((HasType (Op2 (Or) a-expr b-expr) (Bitvector bw)))
  :ruleset typing)
(rule
  ((Op2 (Xor) a-expr b-expr)
   (HasType a-expr (Bitvector bw))
   (HasType b-expr (Bitvector bw)))
  ((HasType (Op2 (Xor) a-expr b-expr) (Bitvector bw)))
  :ruleset typing)
(rule
  ((Op2 (Shr) a-expr b-expr)
   (HasType a-expr (Bitvector bw))
   (HasType b-expr (Bitvector bw)))
  ((HasType (Op2 (Shr) a-expr b-expr) (Bitvector bw)))
  :ruleset typing)
(rule
  ((Op2 (Eq) a-expr b-expr)
   (HasType a-expr (Bitvector bw))
   (HasType b-expr (Bitvector bw)))
  ((HasType (Op2 (Eq) a-expr b-expr) (Bitvector 1)))
  :ruleset typing)
(rule
  ((Op3 (Mux) sel-expr a-expr b-expr)
   (HasType sel-expr (Bitvector 1))
   (HasType a-expr (Bitvector bw))
   (HasType b-expr (Bitvector bw)))
  ((HasType (Op3 (Mux) sel-expr a-expr b-expr) (Bitvector bw)))
  :ruleset typing)
(rule
  ((Concat a-expr b-expr)
   (HasType a-expr (Bitvector m))
   (HasType b-expr (Bitvector n)))
  ((HasType (Concat a-expr b-expr) (Bitvector (+ m n))))
  :ruleset typing)
(rule
  ((Extract high low expr)
   (HasType expr (Bitvector n)))
  ((HasType (Extract high low expr) (Bitvector (+ 1 (- high low)))))
  :ruleset typing)
(rule
  ((ZeroExtend expr bitwidth))
  ((HasType (ZeroExtend expr bitwidth) (Bitvector bitwidth)))
  :ruleset typing)


;;; LUT sketch proposal rewrites.
(ruleset sketch-proposal)
(rule 
  ((Op1 op e) (HasType (Op1 op e) (Bitvector 1)) (HasType e (Bitvector n)) (<= n 4))
  ((union (Op1 op e) (Sketch1 (LUT4) e)))
  :ruleset sketch-proposal)
(rule 
  ((Op2 op e1 e2) (HasType (Op2 op e1 e2) (Bitvector 1)) (HasType e1 (Bitvector m)) (HasType e2 (Bitvector n)) (<= (+ m n) 4))
  ((union (Op2 op e1 e2) (Sketch1 (LUT4) (Concat e1 e2))))
  :ruleset sketch-proposal)
(rule 
  ((Op3 op e1 e2 e3) (HasType (Op3 op e1 e2 e3) (Bitvector 1)) (HasType e1 (Bitvector m)) (HasType e2 (Bitvector n)) (HasType e3 (Bitvector o)) (<= (+ (+ m n) o) 4))
  ((union (Op3 op e1 e2 e3) (Sketch1 (LUT4) (Concat (Concat e1 e2) e3))))
  :ruleset sketch-proposal)


;;; Misc rewrites.
(ruleset misc)
;;; Split up Mux op.
;;; Given a multibit mux expr, split it up into one-bit mux exprs.
(rule
  ((Op3 (Mux) sel-expr a-expr b-expr)
   (HasType sel-expr (Bitvector 1))
   (HasType a-expr (Bitvector n))
   (HasType b-expr (Bitvector n))
   (> n 1))
  ((union 
    (Op3 (Mux) sel-expr a-expr b-expr)
    (Concat 
     (Op3 (Mux) sel-expr (Extract (- n 1) (- n 1) a-expr) (Extract (- n 1) (- n 1) b-expr))
     (Op3 (Mux) sel-expr (Extract (- n 2) 0 a-expr) (Extract (- n 2) 0 b-expr)))))
 :ruleset misc)

; Simplify nested extracts.
(rewrite 
  (Extract hi1 lo1 (Extract hi0 lo0 expr))
  (Extract (+ (+ lo0 lo1) (- hi1 lo1)) (+ lo0 lo1) expr)
  :ruleset misc)

; Simplify Concats of contiguous Extracts.
(rule 
  ((Concat (Extract hi1 lo1 expr) (Extract hi0 lo0 expr))
   (= lo1 (+ hi0 1)))
  ((union 
    (Concat (Extract hi1 lo1 expr) (Extract hi0 lo0 expr))
    (Extract hi1 lo0 expr)))
 :ruleset misc)

 ; Simplify Extracts of Concats.
(rule 
  ((Extract hi lo (Concat e1 e0))
   (HasType e0 (Bitvector bw0))
   (HasType e1 (Bitvector bw1))
   ;;; Check that the extract is only extracting from e1.
   (< hi (+ bw0 bw1))
   (>= lo bw0))
  ((union 
    (Extract hi lo (Concat e1 e0))
    (Extract (- hi bw0) (- lo bw0) e1)))
 :ruleset misc)
(rule 
  ((Extract hi lo (Concat e1 e0))
   (HasType e0 (Bitvector bw0))
   (HasType e1 (Bitvector bw1))
   ;;; Check that the extract is only extracting from e0.
   (< hi bw0))
  ((union 
    (Extract hi lo (Concat e1 e0))
    (Extract hi lo e0)))
 :ruleset misc)
